
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">word-of-wisdom-go/cmd/client/client.go (96.6%)</option>
				
				<option value="file1">word-of-wisdom-go/cmd/client/dialer.go (100.0%)</option>
				
				<option value="file2">word-of-wisdom-go/cmd/client/main.go (57.1%)</option>
				
				<option value="file3">word-of-wisdom-go/cmd/client/root.go (91.7%)</option>
				
				<option value="file4">word-of-wisdom-go/cmd/client/testing.go (92.1%)</option>
				
				<option value="file5">word-of-wisdom-go/cmd/client/wow.go (91.2%)</option>
				
				<option value="file6">word-of-wisdom-go/cmd/server/main.go (57.1%)</option>
				
				<option value="file7">word-of-wisdom-go/cmd/server/root.go (91.3%)</option>
				
				<option value="file8">word-of-wisdom-go/cmd/server/tcp_server.go (71.9%)</option>
				
				<option value="file9">word-of-wisdom-go/pkg/api/tcp/commands/handler.go (90.5%)</option>
				
				<option value="file10">word-of-wisdom-go/pkg/api/tcp/commands/mock_command_handler.go (68.2%)</option>
				
				<option value="file11">word-of-wisdom-go/pkg/api/tcp/server/server.go (92.9%)</option>
				
				<option value="file12">word-of-wisdom-go/pkg/app/challenges/challenges.go (96.0%)</option>
				
				<option value="file13">word-of-wisdom-go/pkg/app/challenges/mock_challenges.go (62.1%)</option>
				
				<option value="file14">word-of-wisdom-go/pkg/app/challenges/mock_request_rate_monitor.go (67.9%)</option>
				
				<option value="file15">word-of-wisdom-go/pkg/app/challenges/monitor.go (100.0%)</option>
				
				<option value="file16">word-of-wisdom-go/pkg/app/wow/mock_query.go (67.9%)</option>
				
				<option value="file17">word-of-wisdom-go/pkg/app/wow/query.go (100.0%)</option>
				
				<option value="file18">word-of-wisdom-go/pkg/di/dig.go (100.0%)</option>
				
				<option value="file19">word-of-wisdom-go/pkg/diag/attributes.go (100.0%)</option>
				
				<option value="file20">word-of-wisdom-go/pkg/diag/mock_slog_handler.go (34.7%)</option>
				
				<option value="file21">word-of-wisdom-go/pkg/diag/slog.go (93.1%)</option>
				
				<option value="file22">word-of-wisdom-go/pkg/diag/testing.go (75.0%)</option>
				
				<option value="file23">word-of-wisdom-go/pkg/services/networking/session.go (100.0%)</option>
				
				<option value="file24">word-of-wisdom-go/pkg/services/networking/testing.go (100.0%)</option>
				
				<option value="file25">word-of-wisdom-go/pkg/services/register.go (100.0%)</option>
				
				<option value="file26">word-of-wisdom-go/pkg/services/testing.go (50.0%)</option>
				
				<option value="file27">word-of-wisdom-go/pkg/services/time.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "os"
        "word-of-wisdom-go/pkg/diag"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

type runWOWCommandParams struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        // client specific deps
        SessionDialer
        WOWCommand

        // Expected in a form host:port
        serverAddress string
        output        io.Writer
}

func runWOWCommand(ctx context.Context, params runWOWCommandParams) error <span class="cov10" title="4">{
        logger := params.RootLogger.WithGroup("client")
        logger.DebugContext(ctx, "Establishing connection", slog.String("address", params.serverAddress))

        session, cleanup, err := params.DialSession("tcp", params.serverAddress)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov8" title="3">defer func() </span><span class="cov8" title="3">{
                if err = cleanup(); err != nil </span><span class="cov1" title="1">{
                        logger.ErrorContext(ctx, "Connection cleanup failed", diag.ErrAttr(err))
                }</span>
        }()
        <span class="cov8" title="3">result, err := params.WOWCommand.Process(ctx, session)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov5" title="2">fmt.Fprintln(params.output, "Your Word of Wisdom for today:")
        fmt.Fprintln(params.output, result)
        return nil</span>
}

func newClientCmd(container *dig.Container) *cobra.Command <span class="cov8" title="3">{
        serverAddress := "localhost:44221"
        cmd := &amp;cobra.Command{
                Use:   "get-wow",
                Short: "Command to connect to the server and get word of wisdom",
        }
        cmd.Flags().StringVarP(&amp;serverAddress, "address", "a", serverAddress, "Server address to connect to")
        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Do not start. Just setup deps and exit. Useful for testing if setup is all working.",
        )
        cmd.RunE = func(cmd *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                ctx := cmd.Context()
                return container.Invoke(func(params runWOWCommandParams) error </span><span class="cov1" title="1">{
                        params.serverAddress = serverAddress
                        params.output = os.Stdout
                        if noop </span><span class="cov1" title="1">{
                                params.RootLogger.InfoContext(ctx, "Establishing connection", slog.String("address", params.serverAddress))
                                return nil
                        }</span>
                        <span class="cov0" title="0">return runWOWCommand(ctx, params)</span>
                })
        }
        <span class="cov8" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "net"
        "word-of-wisdom-go/pkg/services/networking"
)

type SessionDialer interface {
        // DialSession establishes new connection and returns session and close function
        DialSession(network, address string) (networking.Session, func() error, error)
}

type SessionDialerFunc func(network, address string) (networking.Session, func() error, error)

func (f SessionDialerFunc) DialSession(network, address string) (networking.Session, func() error, error) <span class="cov10" title="6">{
        return f(network, address)
}</span>

var _ SessionDialer = SessionDialerFunc(nil)

func dialSession(network, address string) (networking.Session, func() error, error) <span class="cov4" title="2">{
        conn, err := net.Dial(network, address)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("error connecting to server: %w", err)
        }</span>
        <span class="cov1" title="1">session := networking.NewSession(conn.LocalAddr().String(), conn)
        return session, conn.Close, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="3">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newClientCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"
        "word-of-wisdom-go/config"
        "word-of-wisdom-go/pkg/app/challenges"
        "word-of-wisdom-go/pkg/di"
        "word-of-wisdom-go/pkg/diag"
        "word-of-wisdom-go/pkg/services"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        logsOutputFile := ""
        jsonLogs := false
        env := ""

        cmd := &amp;cobra.Command{
                Use:   "client",
                Short: "WoW client",
        }
        cmd.SilenceUsage = true
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().BoolVar(
                &amp;jsonLogs,
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringVarP(
                &amp;env,
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov10" title="3">{
                cfg, err := config.Load(config.NewLoadOpts().WithEnv(env))
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="2">if err = cfg.BindPFlag("defaultLogLevel", cmd.PersistentFlags().Lookup("log-level")); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov6" title="2">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov1" title="1">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(jsonLogs).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),
                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),

                                // app layer
                                challenges.NewChallenges,

                                // client deps
                                di.ProvideValue(SessionDialer(SessionDialerFunc(dialSession))),
                                newWOWCommand,
                        ),

                        // service layer
                        services.Register(container),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to inject dependencies: %w", err)
                }</span>

                <span class="cov1" title="1">return nil</span>
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//go:build !release

package main

import (
        "net"
        "strconv"
        "sync"
)

type connectionData struct {
        message string
}

type mockTCPServer struct {
        listener    net.Listener
        isRunning   bool
        connections []connectionData
        mu          sync.Mutex
}

func newMockTCPServer() *mockTCPServer <span class="cov1" title="1">{
        return &amp;mockTCPServer{}
}</span>

// Start initializes and starts the TCP server on a random port.
func (s *mockTCPServer) Start(port int) error <span class="cov1" title="1">{
        var err error
        s.listener, err = net.Listen("tcp", ":"+strconv.Itoa(port))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">s.isRunning = true

        startupSignal := make(chan struct{})
        go func() </span><span class="cov1" title="1">{
                startupSignal &lt;- struct{}{}
                for </span><span class="cov10" title="2">{
                        var conn net.Conn
                        conn, err = s.listener.Accept()
                        if err != nil </span><span class="cov1" title="1">{
                                if !s.isRunning </span><span class="cov1" title="1">{
                                        return
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov1" title="1">go s.handleConnection(conn)</span>
                }
        }()
        <span class="cov1" title="1">&lt;-startupSignal
        return nil</span>
}

func (s *mockTCPServer) stop() <span class="cov1" title="1">{
        s.isRunning = false
        if s.listener != nil </span><span class="cov1" title="1">{
                s.listener.Close()
        }</span>
}

func (s *mockTCPServer) handleConnection(conn net.Conn) <span class="cov1" title="1">{
        defer conn.Close()
        buffer := make([]byte, 1024)
        for </span><span class="cov10" title="2">{
                n, err := conn.Read(buffer)
                if err != nil </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov1" title="1">message := string(buffer[:n])

                s.mu.Lock()
                s.connections = append(s.connections, connectionData{message: message})
                s.mu.Unlock()

                _, err = conn.Write(buffer[:n])
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

func (s *mockTCPServer) getConnections() []connectionData <span class="cov1" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        return append([]connectionData{}, s.connections...) // Return a copy
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "fmt"
        "log/slog"
        "strconv"
        "strings"
        "time"
        "word-of-wisdom-go/pkg/app/challenges"
        "word-of-wisdom-go/pkg/services/networking"

        "go.uber.org/dig"
)

type WOWCommand interface {
        Process(ctx context.Context, session networking.Session) (string, error)
}

type WOWCommandFunc func(ctx context.Context, session networking.Session) (string, error)

func (f WOWCommandFunc) Process(ctx context.Context, session networking.Session) (string, error) <span class="cov10" title="10">{
        return f(ctx, session)
}</span>

var _ WOWCommandFunc = WOWCommandFunc(nil)

type WOWCommandDeps struct {
        dig.In

        RootLogger *slog.Logger

        // app layer
        challenges.Challenges
}

func newWOWCommand(deps WOWCommandDeps) WOWCommand <span class="cov9" title="8">{
        logger := deps.RootLogger.WithGroup("client")
        return WOWCommandFunc(func(ctx context.Context, session networking.Session) (string, error) </span><span class="cov8" title="7">{
                logger.DebugContext(ctx, "Sending GET_WOW request")

                if err := session.WriteLine("GET_WOW"); err != nil </span><span class="cov1" title="1">{
                        return "", fmt.Errorf("failed to write to the server: %w", err)
                }</span>

                <span class="cov8" title="6">line, err := session.ReadLine()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to read the response: %w", err)
                }</span>

                <span class="cov8" title="6">logger.DebugContext(ctx, "Got response", slog.String("data", line))

                if strings.Index(line, "WOW:") == 0 </span><span class="cov1" title="1">{
                        logger.DebugContext(ctx, "Got WOW response. No challenge required")
                        return strings.Trim(line[4:], " "), nil
                }</span>

                <span class="cov7" title="5">if strings.Index(line, "CHALLENGE_REQUIRED:") != 0 </span><span class="cov1" title="1">{
                        return "", fmt.Errorf("got unexpected challenge requirement response %s: %w", line, err)
                }</span>

                <span class="cov6" title="4">separatorIndex := strings.Index(line, ";")

                challenge := strings.Trim(line[len("CHALLENGE_REQUIRED:"):separatorIndex], " ")
                complexity, err := strconv.Atoi(line[separatorIndex+1:])
                if err != nil </span><span class="cov1" title="1">{
                        return "", err
                }</span>

                <span class="cov5" title="3">solveStartedAt := time.Now()
                solution, err := deps.Challenges.SolveChallenge(ctx, complexity, challenge)
                if err != nil </span><span class="cov1" title="1">{
                        return "", err
                }</span>

                <span class="cov3" title="2">logger.DebugContext(
                        ctx,
                        "Challenge solved. Sending challenge result",
                        slog.Duration("solutionDuration", time.Since(solveStartedAt)),
                        slog.String("solution", solution),
                )
                if err = session.WriteLine("CHALLENGE_RESULT: " + solution); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to write to the server: %w", err)
                }</span>

                <span class="cov3" title="2">line, err = session.ReadLine()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to read the response: %w", err)
                }</span>

                <span class="cov3" title="2">logger.DebugContext(ctx, "Got response", slog.String("data", line))

                if strings.Index(line, "WOW:") == 0 </span><span class="cov1" title="1">{
                        return strings.Trim(line[4:], " "), nil
                }</span>

                <span class="cov1" title="1">return "", fmt.Errorf("got unexpected WOW response %s", line)</span>
        })
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="3">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newTCPServerCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"
        "word-of-wisdom-go/config"
        "word-of-wisdom-go/pkg/api/tcp/commands"
        "word-of-wisdom-go/pkg/api/tcp/server"
        "word-of-wisdom-go/pkg/app/challenges"
        "word-of-wisdom-go/pkg/app/wow"
        "word-of-wisdom-go/pkg/di"
        "word-of-wisdom-go/pkg/diag"
        "word-of-wisdom-go/pkg/services"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        logsOutputFile := ""
        jsonLogs := false
        env := ""

        cmd := &amp;cobra.Command{
                Use:   "server",
                Short: "WoW server",
        }
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().BoolVar(
                &amp;jsonLogs,
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringVarP(
                &amp;env,
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov10" title="3">{
                cfg, err := config.Load(config.NewLoadOpts().WithEnv(env))
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="2">if err = cfg.BindPFlag("defaultLogLevel", cmd.PersistentFlags().Lookup("log-level")); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov6" title="2">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov1" title="1">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(jsonLogs).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),
                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),

                                // api layer
                                commands.NewHandler,
                                server.NewListener,

                                // app layer
                                challenges.NewChallenges,
                                challenges.NewRequestRateMonitor,
                                wow.NewQuery,
                        ),
                        // services
                        services.Register(container),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to inject dependencies: %w", err)
                }</span>

                <span class="cov1" title="1">return nil</span>
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "context"
        "log/slog"
        "os/signal"
        "time"
        "word-of-wisdom-go/pkg/api/tcp/server"
        "word-of-wisdom-go/pkg/diag"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
        "golang.org/x/sys/unix"
)

type runTCPServerParams struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        *server.Listener

        noop bool
}

func runTCPServer(params runTCPServerParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger
        rootCtx := context.Background()

        signalCtx, cancel := signal.NotifyContext(rootCtx, unix.SIGINT, unix.SIGTERM)
        defer cancel()

        startupErrors := make(chan error, 1)
        go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Exiting now")
                        startupErrors &lt;- nil
                        return
                }</span>

                <span class="cov0" title="0">if err := params.Listener.Start(signalCtx); err != nil </span><span class="cov0" title="0">{ // coverage-ignore // challenging to simulate
                        startupErrors &lt;- err
                        return
                }</span>
        }()

        <span class="cov1" title="1">var startupErr error
        select </span>{
        case startupErr = &lt;-startupErrors:<span class="cov1" title="1"> // coverage-ignore // challenging to simulate
                if startupErr != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Server error", "err", startupErr)
                }</span> else<span class="cov1" title="1"> {
                        rootLogger.InfoContext(rootCtx, "Server stopped")
                }</span>
        case &lt;-signalCtx.Done():<span class="cov0" title="0"> // coverage-ignore // challenging to simulate
                rootLogger.InfoContext(rootCtx, "Trying to shut down gracefully")
                ts := time.Now()
                if err := params.Listener.Close(); err != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "graceful shutdown failed", diag.ErrAttr(err))
                }</span>
                <span class="cov0" title="0">rootLogger.InfoContext(rootCtx, "Service stopped",
                        slog.Duration("duration", time.Since(ts)),
                )</span>
        }
        <span class="cov1" title="1">return startupErr</span>
}

func newTCPServerCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        cmd := &amp;cobra.Command{
                Use:   "tcp",
                Short: "Start tcp server",
        }
        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Do not start. Just setup deps and exit. Useful for testing if setup is all working.",
        )
        cmd.RunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return container.Invoke(func(params runTCPServerParams) error </span><span class="cov1" title="1">{
                        params.noop = noop
                        return runTCPServer(params)
                }</span>)
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package commands

import (
        "context"
        "fmt"
        "log/slog"
        "strings"
        "word-of-wisdom-go/pkg/app/challenges"
        "word-of-wisdom-go/pkg/app/wow"
        "word-of-wisdom-go/pkg/diag"
        "word-of-wisdom-go/pkg/services/networking"

        "go.uber.org/dig"
)

type CommandHandlerDeps struct {
        dig.In

        RootLogger *slog.Logger

        // components
        challenges.RequestRateMonitor
        challenges.Challenges
        wow.Query
}

type CommandHandler interface {
        Handle(ctx context.Context, con networking.Session) error
}

type commandHandler struct {
        CommandHandlerDeps
        logger *slog.Logger
}

func (h *commandHandler) trace(ctx context.Context, msg string, args ...any) <span class="cov8" title="6">{
        h.logger.DebugContext(ctx, msg, args...)
}</span>

func NewHandler(deps CommandHandlerDeps) CommandHandler <span class="cov10" title="9">{
        return &amp;commandHandler{
                CommandHandlerDeps: deps,
                logger:             deps.RootLogger.WithGroup("tcp.server.handler"),
        }
}</span>

func (h *commandHandler) performChallengeVerification(
        ctx context.Context,
        con networking.Session,
        monitoringResult challenges.RecordRequestResult,
) (bool, error) <span class="cov5" title="3">{
        var challenge string
        challenge, err := h.Challenges.GenerateNewChallenge(con.ClientID())
        if err != nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("failed to generate new challenge: %w", err)
        }</span>

        <span class="cov3" title="2">h.trace(ctx, "Requiring to solve challenge", slog.Int("complexity", monitoringResult.ChallengeComplexity))
        challengeData := fmt.Sprintf("CHALLENGE_REQUIRED: %s;%d", challenge, monitoringResult.ChallengeComplexity)
        if err = con.WriteLine(challengeData); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov3" title="2">var cmd string
        if cmd, err = con.ReadLine(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov3" title="2">if strings.Index(cmd, "CHALLENGE_RESULT:") != 0 </span><span class="cov0" title="0">{
                h.trace(ctx, "Got unexpected challenge result", slog.String("data", cmd))
                return false, con.WriteLine("ERR: UNEXPECTED_CHALLENGE_RESULT")
        }</span>

        <span class="cov3" title="2">if !h.Challenges.VerifySolution(
                monitoringResult.ChallengeComplexity,
                challenge,
                strings.Trim(cmd[len("CHALLENGE_RESULT:"):], " "),
        ) </span><span class="cov1" title="1">{
                h.trace(ctx, "Challenge verification failed", slog.String("data", cmd))
                return false, con.WriteLine("ERR: CHALLENGE_VERIFICATION_FAILED")
        }</span>
        <span class="cov1" title="1">return true, nil</span>
}

func (h *commandHandler) Handle(ctx context.Context, con networking.Session) error <span class="cov9" title="8">{
        cmd, err := con.ReadLine()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // If we need to extend it to support multiple commands
        // then this will need to be refactored roughly as follows:
        // - new Commands component is added that implement all various commands
        // - the HandleCommands will read the command from the connection, and forward the processing to particular
        //   command implementation
        // Keeping it simple for now since we need just a single command.
        <span class="cov8" title="7">if cmd != "GET_WOW" </span><span class="cov1" title="1">{
                h.trace(ctx, "Got bad command", slog.String("cmd", cmd))
                return con.WriteLine("ERR: BAD_CMD")
        }</span>

        <span class="cov8" title="6">monitoringResult, err := h.RequestRateMonitor.RecordRequest(ctx, con.ClientID())
        if err != nil </span><span class="cov1" title="1">{
                h.logger.ErrorContext(ctx,
                        "Failed to record request",
                        slog.String("clientID", con.ClientID()),
                        diag.ErrAttr(err),
                )
                return con.WriteLine("ERR: INTERNAL_ERROR")
        }</span>

        <span class="cov7" title="5">if monitoringResult.ChallengeRequired </span><span class="cov5" title="3">{
                var ok bool
                ok, err = h.performChallengeVerification(ctx, con, monitoringResult)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov3" title="2">if !ok </span><span class="cov1" title="1">{
                        return nil
                }</span>
        }

        <span class="cov5" title="3">wow, err := h.Query.GetNextWoW(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get next wow: %w", err)
        }</span>

        <span class="cov3" title="2">h.trace(ctx, "Responding with WOW")
        return con.WriteLine("WOW: " + wow)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package commands

import (
        context "context"
        networking "word-of-wisdom-go/pkg/services/networking"

        mock "github.com/stretchr/testify/mock"
)

// MockCommandHandler is an autogenerated mock type for the CommandHandler type
type MockCommandHandler struct {
        mock.Mock
}

type MockCommandHandler_Expecter struct {
        mock *mock.Mock
}

func (_m *MockCommandHandler) EXPECT() *MockCommandHandler_Expecter <span class="cov6" title="2">{
        return &amp;MockCommandHandler_Expecter{mock: &amp;_m.Mock}
}</span>

// Handle provides a mock function with given fields: ctx, con
func (_m *MockCommandHandler) Handle(ctx context.Context, con networking.Session) error <span class="cov6" title="2">{
        ret := _m.Called(ctx, con)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Handle")</span>
        }

        <span class="cov6" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, networking.Session) error); ok </span><span class="cov6" title="2">{
                r0 = rf(ctx, con)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov6" title="2">return r0</span>
}

// MockCommandHandler_Handle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Handle'
type MockCommandHandler_Handle_Call struct {
        *mock.Call
}

// Handle is a helper method to define mock.On call
//   - ctx context.Context
//   - con networking.Session
func (_e *MockCommandHandler_Expecter) Handle(ctx interface{}, con interface{}) *MockCommandHandler_Handle_Call <span class="cov6" title="2">{
        return &amp;MockCommandHandler_Handle_Call{Call: _e.mock.On("Handle", ctx, con)}
}</span>

func (_c *MockCommandHandler_Handle_Call) Run(run func(ctx context.Context, con networking.Session)) *MockCommandHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(networking.Session))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockCommandHandler_Handle_Call) Return(_a0 error) *MockCommandHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockCommandHandler_Handle_Call) RunAndReturn(run func(context.Context, networking.Session) error) *MockCommandHandler_Handle_Call <span class="cov6" title="2">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockCommandHandler creates a new instance of MockCommandHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCommandHandler(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockCommandHandler <span class="cov10" title="3">{
        mock := &amp;MockCommandHandler{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="3">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="3">return mock</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package server

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net"
        "strings"
        "word-of-wisdom-go/pkg/api/tcp/commands"
        "word-of-wisdom-go/pkg/diag"
        "word-of-wisdom-go/pkg/services/networking"

        "go.uber.org/dig"
)

type ListenerDeps struct {
        dig.In

        RootLogger *slog.Logger

        // config
        Port int `name:"config.tcpServer.port"`

        // components
        commands.CommandHandler
}

type Listener struct {
        logger          *slog.Logger
        listener        net.Listener
        commandHandler  commands.CommandHandler
        port            int
        listeningSignal chan struct{}
}

func NewListener(deps ListenerDeps) *Listener <span class="cov10" title="4">{
        return &amp;Listener{
                port:            deps.Port,
                commandHandler:  deps.CommandHandler,
                logger:          deps.RootLogger.WithGroup("tcp.server"),
                listeningSignal: make(chan struct{}),
        }
}</span>

func extractHost(addr string) string <span class="cov10" title="4">{
        sepIndex := strings.Index(addr, ":")
        if sepIndex &gt;= 0 </span><span class="cov8" title="3">{
                return addr[:sepIndex]
        }</span>
        <span class="cov1" title="1">return addr</span>
}

func (l *Listener) processAcceptedConnection(ctx context.Context, c net.Conn) <span class="cov5" title="2">{
        remoteAddr := c.RemoteAddr().String()
        l.logger.InfoContext(ctx, "Connection accepted", slog.String("remoteAddr", remoteAddr))
        defer c.Close()
        session := networking.NewSession(extractHost(remoteAddr), c)
        if err := l.commandHandler.Handle(ctx, session); err != nil </span><span class="cov1" title="1">{
                l.logger.ErrorContext(ctx,
                        "Failed processing command",
                        diag.ErrAttr(err),
                        slog.String("remoteAddr", remoteAddr),
                )
        }</span>
}

func (l *Listener) Start(ctx context.Context) error <span class="cov5" title="2">{
        l.logger.InfoContext(ctx, "Starting tcp listener", slog.Int("port", l.port))
        var err error
        l.listener, err = net.Listen("tcp", fmt.Sprintf(":%d", l.port))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="2">close(l.listeningSignal)

        for </span><span class="cov10" title="4">{
                c, acceptErr := l.listener.Accept()
                if acceptErr != nil </span><span class="cov5" title="2">{
                        // Server stopped
                        if errors.Is(acceptErr, net.ErrClosed) </span><span class="cov5" title="2">{
                                return nil
                        }</span>

                        // TODO: Not sure if it worth shutting down the server. Logging for now
                        // Ideally we add a health check that will prove that the server is alive
                        <span class="cov0" title="0">l.logger.ErrorContext(ctx, "failed to accept connection", diag.ErrAttr(acceptErr))</span>
                }

                // TODO: Some sort of middleware to inject correlationId
                <span class="cov5" title="2">go l.processAcceptedConnection(ctx, c)</span>
        }
}

func (l *Listener) WaitListening() <span class="cov5" title="2">{
        &lt;-l.listeningSignal
}</span>

func (l *Listener) Close() error <span class="cov8" title="3">{
        if l.listener == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov5" title="2">return l.listener.Close()</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package challenges

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "math/big"
        "strconv"
        "word-of-wisdom-go/pkg/services"

        "go.uber.org/dig"
)

const zeroByte = 48

func computeHash(input []byte) []byte <span class="cov8" title="244">{
        hash := sha256.New()
        hash.Write(input)
        return hash.Sum(nil)
}</span>

func countLeadingZeros(hash []byte) int <span class="cov8" title="363">{
        count := 0
        for _, char := range hash </span><span class="cov10" title="772">{
                if char == zeroByte </span><span class="cov9" title="409">{
                        count++
                }</span> else<span class="cov8" title="363"> {
                        break</span>
                }
        }
        <span class="cov8" title="363">return count</span>
}

type Challenges interface {
        GenerateNewChallenge(clientID string) (string, error)
        VerifySolution(
                complexity int,
                challenge string,
                solution string,
        ) bool

        // SolveChallenge returns a nonce that is a solution of the challenge.
        // It is used by client side only and
        // in real world scenario this may sit in it's own repo
        // but keeping it simple for now.
        // Returns error if the solution was not found
        SolveChallenge(
                ctx context.Context,
                complexity int,
                challenge string,
        ) (string, error)
}

type Deps struct {
        dig.In `ignore-unexported:"true"`

        // services
        services.TimeProvider
        services.CryptoRandReader

        computeHashFn func(input []byte) []byte
}

type challenges struct {
        Deps
}

func (c *challenges) generateRandomBytes(size int) ([]byte, error) <span class="cov1" title="2">{
        nonce := make([]byte, size)
        _, err := c.CryptoRandReader(nonce)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="2">return nonce, nil</span>
}

func (c *challenges) GenerateNewChallenge(clientID string) (string, error) <span class="cov1" title="2">{
        nowBytes := big.NewInt(c.Now().UnixNano()).Bytes()
        nonce, err := c.generateRandomBytes(16) // TODO: may need to make it smaller (or configurable)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="2">challengeBytes := make([]byte, len(nowBytes)+len(nonce)+len(clientID))
        copy(challengeBytes, []byte(clientID))
        copy(challengeBytes[len(clientID):], nowBytes)
        copy(challengeBytes[len(clientID)+len(nowBytes):], nonce)
        return hex.EncodeToString(challengeBytes), nil</span>
}

func (c *challenges) VerifySolution(
        complexity int,
        challenge string,
        solution string,
) bool <span class="cov2" title="3">{
        hashInputBytes := make([]byte, len(challenge)+len(solution)+1)
        copy(hashInputBytes, []byte(challenge))
        hashInputBytes[len(challenge)] = ':'
        copy(hashInputBytes[len(challenge)+1:], []byte(solution))
        actualHash := c.computeHashFn(hashInputBytes)
        leadingZerosNum := countLeadingZeros(actualHash)
        return leadingZerosNum &gt;= complexity
}</span>

func (c *challenges) SolveChallenge(ctx context.Context, complexity int, challenge string) (string, error) <span class="cov2" title="3">{
        challengePartEnd := len(challenge)
        hashInput := make([]byte, challengePartEnd+20) // we reserve 20 bytes for solution which should be enough
        copy(hashInput, []byte(challenge))
        hashInput[challengePartEnd] = ':'
        nonce := 0

        // TODO: If no deadline, set default deadline (configurable)
        deadline, hasDeadline := ctx.Deadline()

        for </span><span class="cov8" title="360">{
                nonceStr := strconv.Itoa(nonce)
                copy(hashInput[challengePartEnd+1:], []byte(nonceStr))
                hash := c.computeHashFn(hashInput[:challengePartEnd+1+len(nonceStr)])
                leadingZeros := countLeadingZeros(hash)
                if leadingZeros &gt;= complexity </span><span class="cov1" title="2">{
                        return nonceStr, nil
                }</span>

                // TODO: Make sure to set the deadline on caller
                <span class="cov8" title="358">if hasDeadline &amp;&amp; c.Deps.Now().UnixNano() &gt;= deadline.UnixNano() </span><span class="cov1" title="1">{
                        break</span>
                }

                <span class="cov8" title="357">nonce++</span>
        }
        <span class="cov1" title="1">return "", errors.New("failed to solve challenge: deadline reached")</span>
}

func NewChallenges(deps Deps) Challenges <span class="cov3" title="8">{
        if deps.computeHashFn == nil </span><span class="cov2" title="4">{
                deps.computeHashFn = computeHash
        }</span>
        <span class="cov3" title="8">return &amp;challenges{
                Deps: deps,
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package challenges

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockChallenges is an autogenerated mock type for the Challenges type
type MockChallenges struct {
        mock.Mock
}

type MockChallenges_Expecter struct {
        mock *mock.Mock
}

func (_m *MockChallenges) EXPECT() *MockChallenges_Expecter <span class="cov7" title="8">{
        return &amp;MockChallenges_Expecter{mock: &amp;_m.Mock}
}</span>

// GenerateNewChallenge provides a mock function with given fields: clientID
func (_m *MockChallenges) GenerateNewChallenge(clientID string) (string, error) <span class="cov4" title="3">{
        ret := _m.Called(clientID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GenerateNewChallenge")</span>
        }

        <span class="cov4" title="3">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(clientID)
        }</span>
        <span class="cov4" title="3">if rf, ok := ret.Get(0).(func(string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(clientID)
        }</span> else<span class="cov4" title="3"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov4" title="3">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(clientID)
        }</span> else<span class="cov4" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="3">return r0, r1</span>
}

// MockChallenges_GenerateNewChallenge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateNewChallenge'
type MockChallenges_GenerateNewChallenge_Call struct {
        *mock.Call
}

// GenerateNewChallenge is a helper method to define mock.On call
//   - clientID string
func (_e *MockChallenges_Expecter) GenerateNewChallenge(clientID interface{}) *MockChallenges_GenerateNewChallenge_Call <span class="cov4" title="3">{
        return &amp;MockChallenges_GenerateNewChallenge_Call{Call: _e.mock.On("GenerateNewChallenge", clientID)}
}</span>

func (_c *MockChallenges_GenerateNewChallenge_Call) Run(run func(clientID string)) *MockChallenges_GenerateNewChallenge_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockChallenges_GenerateNewChallenge_Call) Return(_a0 string, _a1 error) *MockChallenges_GenerateNewChallenge_Call <span class="cov4" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockChallenges_GenerateNewChallenge_Call) RunAndReturn(run func(string) (string, error)) *MockChallenges_GenerateNewChallenge_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// SolveChallenge provides a mock function with given fields: ctx, complexity, challenge
func (_m *MockChallenges) SolveChallenge(ctx context.Context, complexity int, challenge string) (string, error) <span class="cov4" title="3">{
        ret := _m.Called(ctx, complexity, challenge)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SolveChallenge")</span>
        }

        <span class="cov4" title="3">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int, string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, complexity, challenge)
        }</span>
        <span class="cov4" title="3">if rf, ok := ret.Get(0).(func(context.Context, int, string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, complexity, challenge)
        }</span> else<span class="cov4" title="3"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov4" title="3">if rf, ok := ret.Get(1).(func(context.Context, int, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, complexity, challenge)
        }</span> else<span class="cov4" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="3">return r0, r1</span>
}

// MockChallenges_SolveChallenge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SolveChallenge'
type MockChallenges_SolveChallenge_Call struct {
        *mock.Call
}

// SolveChallenge is a helper method to define mock.On call
//   - ctx context.Context
//   - complexity int
//   - challenge string
func (_e *MockChallenges_Expecter) SolveChallenge(ctx interface{}, complexity interface{}, challenge interface{}) *MockChallenges_SolveChallenge_Call <span class="cov4" title="3">{
        return &amp;MockChallenges_SolveChallenge_Call{Call: _e.mock.On("SolveChallenge", ctx, complexity, challenge)}
}</span>

func (_c *MockChallenges_SolveChallenge_Call) Run(run func(ctx context.Context, complexity int, challenge string)) *MockChallenges_SolveChallenge_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(int), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockChallenges_SolveChallenge_Call) Return(_a0 string, _a1 error) *MockChallenges_SolveChallenge_Call <span class="cov4" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockChallenges_SolveChallenge_Call) RunAndReturn(run func(context.Context, int, string) (string, error)) *MockChallenges_SolveChallenge_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// VerifySolution provides a mock function with given fields: complexity, challenge, solution
func (_m *MockChallenges) VerifySolution(complexity int, challenge string, solution string) bool <span class="cov3" title="2">{
        ret := _m.Called(complexity, challenge, solution)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for VerifySolution")</span>
        }

        <span class="cov3" title="2">var r0 bool
        if rf, ok := ret.Get(0).(func(int, string, string) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(complexity, challenge, solution)
        }</span> else<span class="cov3" title="2"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov3" title="2">return r0</span>
}

// MockChallenges_VerifySolution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifySolution'
type MockChallenges_VerifySolution_Call struct {
        *mock.Call
}

// VerifySolution is a helper method to define mock.On call
//   - complexity int
//   - challenge string
//   - solution string
func (_e *MockChallenges_Expecter) VerifySolution(complexity interface{}, challenge interface{}, solution interface{}) *MockChallenges_VerifySolution_Call <span class="cov3" title="2">{
        return &amp;MockChallenges_VerifySolution_Call{Call: _e.mock.On("VerifySolution", complexity, challenge, solution)}
}</span>

func (_c *MockChallenges_VerifySolution_Call) Run(run func(complexity int, challenge string, solution string)) *MockChallenges_VerifySolution_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(int), args[1].(string), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockChallenges_VerifySolution_Call) Return(_a0 bool) *MockChallenges_VerifySolution_Call <span class="cov3" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockChallenges_VerifySolution_Call) RunAndReturn(run func(int, string, string) bool) *MockChallenges_VerifySolution_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockChallenges creates a new instance of MockChallenges. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockChallenges(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockChallenges <span class="cov10" title="15">{
        mock := &amp;MockChallenges{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="15">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="15">return mock</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package challenges

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockRequestRateMonitor is an autogenerated mock type for the RequestRateMonitor type
type MockRequestRateMonitor struct {
        mock.Mock
}

type MockRequestRateMonitor_Expecter struct {
        mock *mock.Mock
}

func (_m *MockRequestRateMonitor) EXPECT() *MockRequestRateMonitor_Expecter <span class="cov8" title="6">{
        return &amp;MockRequestRateMonitor_Expecter{mock: &amp;_m.Mock}
}</span>

// RecordRequest provides a mock function with given fields: ctx, clientID
func (_m *MockRequestRateMonitor) RecordRequest(ctx context.Context, clientID string) (RecordRequestResult, error) <span class="cov8" title="6">{
        ret := _m.Called(ctx, clientID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for RecordRequest")</span>
        }

        <span class="cov8" title="6">var r0 RecordRequestResult
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (RecordRequestResult, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, clientID)
        }</span>
        <span class="cov8" title="6">if rf, ok := ret.Get(0).(func(context.Context, string) RecordRequestResult); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, clientID)
        }</span> else<span class="cov8" title="6"> {
                r0 = ret.Get(0).(RecordRequestResult)
        }</span>

        <span class="cov8" title="6">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, clientID)
        }</span> else<span class="cov8" title="6"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="6">return r0, r1</span>
}

// MockRequestRateMonitor_RecordRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordRequest'
type MockRequestRateMonitor_RecordRequest_Call struct {
        *mock.Call
}

// RecordRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - clientID string
func (_e *MockRequestRateMonitor_Expecter) RecordRequest(ctx interface{}, clientID interface{}) *MockRequestRateMonitor_RecordRequest_Call <span class="cov8" title="6">{
        return &amp;MockRequestRateMonitor_RecordRequest_Call{Call: _e.mock.On("RecordRequest", ctx, clientID)}
}</span>

func (_c *MockRequestRateMonitor_RecordRequest_Call) Run(run func(ctx context.Context, clientID string)) *MockRequestRateMonitor_RecordRequest_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockRequestRateMonitor_RecordRequest_Call) Return(_a0 RecordRequestResult, _a1 error) *MockRequestRateMonitor_RecordRequest_Call <span class="cov8" title="6">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockRequestRateMonitor_RecordRequest_Call) RunAndReturn(run func(context.Context, string) (RecordRequestResult, error)) *MockRequestRateMonitor_RecordRequest_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockRequestRateMonitor creates a new instance of MockRequestRateMonitor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRequestRateMonitor(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockRequestRateMonitor <span class="cov10" title="8">{
        mock := &amp;MockRequestRateMonitor{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="8">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="8">return mock</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package challenges

import (
        "context"
        "sync"
        "sync/atomic"
        "time"
        "word-of-wisdom-go/pkg/services"

        "go.uber.org/dig"
)

type RecordRequestResult struct {
        ChallengeRequired   bool
        ChallengeComplexity int
}

type RequestRateMonitor interface {
        RecordRequest(ctx context.Context, clientID string) (RecordRequestResult, error)
}

type RequestRateMonitorDeps struct {
        dig.In

        // config

        // WindowDuration specifies max window duration to reset metrics
        WindowDuration time.Duration `name:"config.monitoring.windowDuration"`

        // MaxUnverifiedClientRequests max allowed unverified requests per client within the window
        MaxUnverifiedClientRequests int64 `name:"config.monitoring.maxUnverifiedClientRequests"`

        // MaxUnverifiedRequests max allowed unverified requests globally within the window
        MaxUnverifiedRequests int64 `name:"config.monitoring.maxUnverifiedRequests"`

        // services
        services.TimeProvider
}

type requestRateMonitor struct {
        RequestRateMonitorDeps

        requestRateByClient sync.Map
        globalRequestsCount atomic.Int64

        // timestamp in ms when the window was started
        windowStartedAt atomic.Int64
}

func (m *requestRateMonitor) RecordRequest(_ context.Context, clientID string) (RecordRequestResult, error) <span class="cov10" title="420">{
        // We are not using the context yet, but in a real world system it may be required
        // since we will very likely store counters somewhere

        // This is a naive implementation based on a fixed window algo
        // in a real world system we will need to support distributed scenario
        // and keep this data in something like redis, or use some other replication mechanism
        // and also use some sliding window algo with per client window.

        challengeRequired := false
        complexityRequired := 0

        now := m.Now().UnixMilli()
        lastTimestamp := m.windowStartedAt.Load()
        if now-lastTimestamp &gt; m.WindowDuration.Milliseconds() </span><span class="cov3" title="7">{
                if m.windowStartedAt.CompareAndSwap(lastTimestamp, now) </span><span class="cov3" title="7">{
                        m.globalRequestsCount.Store(0)
                        m.requestRateByClient.Clear()
                }</span>
        }

        <span class="cov10" title="420">currentClientCounter, _ := m.requestRateByClient.LoadOrStore(clientID, new(int64))
        nextClientCounter := atomic.AddInt64(currentClientCounter.(*int64), 1)
        if nextClientCounter &gt; m.MaxUnverifiedClientRequests </span><span class="cov2" title="3">{
                challengeRequired = true
                complexityRequired = 1
        }</span>

        <span class="cov10" title="420">nextGlobalCount := m.globalRequestsCount.Add(1)
        if !challengeRequired &amp;&amp; nextGlobalCount &gt; m.MaxUnverifiedRequests </span><span class="cov2" title="3">{
                challengeRequired = true
                complexityRequired = 1
        }</span>

        <span class="cov10" title="420">return RecordRequestResult{
                ChallengeRequired:   challengeRequired,
                ChallengeComplexity: complexityRequired,
        }, nil</span>
}

func NewRequestRateMonitor(deps RequestRateMonitorDeps) RequestRateMonitor <span class="cov3" title="6">{
        return &amp;requestRateMonitor{
                RequestRateMonitorDeps: deps,
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package wow

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockQuery is an autogenerated mock type for the Query type
type MockQuery struct {
        mock.Mock
}

type MockQuery_Expecter struct {
        mock *mock.Mock
}

func (_m *MockQuery) EXPECT() *MockQuery_Expecter <span class="cov5" title="3">{
        return &amp;MockQuery_Expecter{mock: &amp;_m.Mock}
}</span>

// GetNextWoW provides a mock function with given fields: ctx
func (_m *MockQuery) GetNextWoW(ctx context.Context) (string, error) <span class="cov5" title="3">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetNextWoW")</span>
        }

        <span class="cov5" title="3">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov5" title="3">if rf, ok := ret.Get(0).(func(context.Context) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov5" title="3"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov5" title="3">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov5" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="3">return r0, r1</span>
}

// MockQuery_GetNextWoW_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextWoW'
type MockQuery_GetNextWoW_Call struct {
        *mock.Call
}

// GetNextWoW is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQuery_Expecter) GetNextWoW(ctx interface{}) *MockQuery_GetNextWoW_Call <span class="cov5" title="3">{
        return &amp;MockQuery_GetNextWoW_Call{Call: _e.mock.On("GetNextWoW", ctx)}
}</span>

func (_c *MockQuery_GetNextWoW_Call) Run(run func(ctx context.Context)) *MockQuery_GetNextWoW_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockQuery_GetNextWoW_Call) Return(_a0 string, _a1 error) *MockQuery_GetNextWoW_Call <span class="cov5" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockQuery_GetNextWoW_Call) RunAndReturn(run func(context.Context) (string, error)) *MockQuery_GetNextWoW_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockQuery creates a new instance of MockQuery. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockQuery(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockQuery <span class="cov10" title="8">{
        mock := &amp;MockQuery{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="8">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="8">return mock</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">//nolint:lll //hardcoded wow phrases
package wow

import (
        "context"
        "math/rand/v2"
)

type Query interface {
        GetNextWoW(ctx context.Context) (string, error)
}

type query struct {
        phrases []string
}

func (q *query) GetNextWoW(_ context.Context) (string, error) <span class="cov10" title="2">{
        // Using hardcoded list of phrases
        // We may want to change it to go to some API to get a next phrase
        // and fallback to the below if it failed. Or store them in a DB...

        nextIndex := rand.IntN(len(q.phrases)) //nolint:gosec //math/rand is ok here
        return q.phrases[nextIndex], nil
}</span>

func NewQuery() Query <span class="cov10" title="2">{
        return &amp;query{
                phrases: []string{
                        "You create your own opportunities. Success doesnt just come and find youyou have to go out and get it.",
                        "Never break your promises. Keep every promise; it makes you credible.",
                        "You are never as stuck as you think you are. Success is not final, and failure isnt fatal.",
                        "Happiness is a choice. For every minute you are angry, you lose 60 seconds of your own happiness.",
                        "Habits develop into character. Character is the result of our mental attitude and the way we spend our time.",
                        "Be happy with who you are. Being happy doesnt mean everything is perfect but that you have decided to look beyond the imperfections.",
                        "Dont seek happinesscreate it. You dont need life to go your way to be happy.",
                        "If you want to be happy, stop complaining. If you want happiness, stop complaining about how your life isnt what you want and make it into what you do want.",
                        "Asking for help is a sign of strength. Dont let your fear of being judged stop you from asking for help when you need it. Sometimes asking for help is the bravest move you can make. You dont have to go it alone.",
                        "Replace every negative thought with a positive one. A positive mind is stronger than a negative thought.",
                        "Accept what is, let go of what was, have faith in what will be. Sometimes you have to let go to let new things come in.",
                        "A mind that is stretched by a new experience can never go back to what it was. Experience is what causes a person to make new mistakes instead of old ones.",
                        "If you are not willing to learn, no one can help you. If you are determined to learn no one can stop you.",
                        "Be confident enough to encourage confidence in others. Show those around you that you have confidence in them.",
                        "Allow others to figure things out for themselves. The fixer ends up becoming the enabler. Let people figure it out for themselves; give them a chance to learn.",
                        "Confidence is essential for a successful life. Dont compare yourself to others; compare yourself to the person you were yesterday and give yourself the confidence to be better tomorrow.",
                        "Admit your mistakes and dont repeat them. If you cant admit your mistakes, you are destined to repeat them.",
                        "Be kind to yourself and forgive yourself. You cant know what you havent yet learned, you cant become proficient without first being a beginner and you cant be perfect. Welcome to the human race.",
                        "Failures are lessons in progress. Failure is always forgivable if you have the courage to learn its lessons and move forward in a new way.",
                        "Make amends with those who have wronged you. Apologizing doesnt always mean that youre wrong and the other person is right. It just means that you value your relationships more than your ego.",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package di

import (
        "fmt"

        "go.uber.org/dig"
)

// Dig is used as DI toolkit https://pkg.go.dev/go.uber.org/dig
// we are not creating any abstraction over it, but we do have a set of tools to make it easier to use

type ConstructorWithOpts struct {
        Constructor interface{}
        Options     []dig.ProvideOption
}

func ProvideAll(container *dig.Container, providers ...interface{}) error <span class="cov7" title="12">{
        for i, provider := range providers </span><span class="cov10" title="35">{
                switch p := provider.(type) </span>{
                case ConstructorWithOpts:<span class="cov8" title="20">
                        if err := container.Provide(p.Constructor, p.Options...); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                default:<span class="cov7" title="15">
                        if err := container.Provide(provider); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                }
        }
        <span class="cov6" title="10">return nil</span>
}

// ProvideValue will create a constructor (e.g func) from a given value.
func ProvideValue[T any](val T, opts ...dig.ProvideOption) ConstructorWithOpts <span class="cov8" title="21">{
        return ConstructorWithOpts{
                Constructor: func() T </span><span class="cov7" title="13">{ return val }</span>,
                Options:     opts,
        }
}

// ProvideWithArg will create a constructor with a first arg explicitly provided
// supposed return no error.
func ProvideWithArg[
        TArg any,
        TConstructorArg any,
        TRes any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) TRes,
) func(TConstructorArg) TRes <span class="cov1" title="1">{
        return func(cArg TConstructorArg) TRes </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideWithArgErr will create a constructor with a first arg explicitly provided
// supposed return an error.
func ProvideWithArgErr[
        TArg any,
        TConstructorArg any,
        TDep any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) (TDep, error),
) func(TConstructorArg) (TDep, error) <span class="cov1" title="1">{
        return func(cArg TConstructorArg) (TDep, error) </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package diag

import "log/slog"

func ErrAttr(err error) slog.Attr <span class="cov10" title="3">{
        return slog.Any("err", err)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package diag

import (
        context "context"
        slog "log/slog"

        mock "github.com/stretchr/testify/mock"
)

// MockSlogHandler is an autogenerated mock type for the Handler type
type MockSlogHandler struct {
        mock.Mock
}

type MockSlogHandler_Expecter struct {
        mock *mock.Mock
}

func (_m *MockSlogHandler) EXPECT() *MockSlogHandler_Expecter <span class="cov8" title="3">{
        return &amp;MockSlogHandler_Expecter{mock: &amp;_m.Mock}
}</span>

// Enabled provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Enabled(_a0 context.Context, _a1 slog.Level) bool <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Enabled")</span>
        }

        <span class="cov0" title="0">var r0 bool
        if rf, ok := ret.Get(0).(func(context.Context, slog.Level) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_Enabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enabled'
type MockSlogHandler_Enabled_Call struct {
        *mock.Call
}

// Enabled is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Level
func (_e *MockSlogHandler_Expecter) Enabled(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_Enabled_Call{Call: _e.mock.On("Enabled", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Enabled_Call) Run(run func(_a0 context.Context, _a1 slog.Level)) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Level))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Enabled_Call) Return(_a0 bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Enabled_Call) RunAndReturn(run func(context.Context, slog.Level) bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Handle provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Handle(_a0 context.Context, _a1 slog.Record) error <span class="cov5" title="2">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Handle")</span>
        }

        <span class="cov5" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, slog.Record) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov5" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov5" title="2">return r0</span>
}

// MockSlogHandler_Handle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Handle'
type MockSlogHandler_Handle_Call struct {
        *mock.Call
}

// Handle is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Record
func (_e *MockSlogHandler_Expecter) Handle(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        return &amp;MockSlogHandler_Handle_Call{Call: _e.mock.On("Handle", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Handle_Call) Run(run func(_a0 context.Context, _a1 slog.Record)) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Record))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Handle_Call) Return(_a0 error) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Handle_Call) RunAndReturn(run func(context.Context, slog.Record) error) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithAttrs provides a mock function with given fields: attrs
func (_m *MockSlogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov1" title="1">{
        ret := _m.Called(attrs)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithAttrs")</span>
        }

        <span class="cov1" title="1">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func([]slog.Attr) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(attrs)
        }</span> else<span class="cov1" title="1"> {
                if ret.Get(0) != nil </span><span class="cov1" title="1">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov1" title="1">return r0</span>
}

// MockSlogHandler_WithAttrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithAttrs'
type MockSlogHandler_WithAttrs_Call struct {
        *mock.Call
}

// WithAttrs is a helper method to define mock.On call
//   - attrs []slog.Attr
func (_e *MockSlogHandler_Expecter) WithAttrs(attrs interface{}) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        return &amp;MockSlogHandler_WithAttrs_Call{Call: _e.mock.On("WithAttrs", attrs)}
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) Run(run func(attrs []slog.Attr)) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].([]slog.Attr))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithAttrs_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) RunAndReturn(run func([]slog.Attr) slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithGroup provides a mock function with given fields: name
func (_m *MockSlogHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithGroup")</span>
        }

        <span class="cov0" title="0">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func(string) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_WithGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithGroup'
type MockSlogHandler_WithGroup_Call struct {
        *mock.Call
}

// WithGroup is a helper method to define mock.On call
//   - name string
func (_e *MockSlogHandler_Expecter) WithGroup(name interface{}) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_WithGroup_Call{Call: _e.mock.On("WithGroup", name)}
}</span>

func (_c *MockSlogHandler_WithGroup_Call) Run(run func(name string)) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithGroup_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithGroup_Call) RunAndReturn(run func(string) slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockSlogHandler creates a new instance of MockSlogHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSlogHandler(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockSlogHandler <span class="cov10" title="4">{
        mock := &amp;MockSlogHandler{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="4">return mock</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package diag

import (
        "context"
        "io"
        "log/slog"
        "os"
)

type contextKey string

const (
        contextDiagAttrs = contextKey("diag.context-key.log-attribs")
)

type LogAttributes struct {
        CorrelationID slog.Value
}

func GetLogAttributesFromContext(ctx context.Context) LogAttributes <span class="cov4" title="3">{
        res, _ := ctx.Value(contextDiagAttrs).(LogAttributes)
        return res
}</span>

func SetLogAttributesToContext(ctx context.Context, attributes LogAttributes) context.Context <span class="cov2" title="2">{
        return context.WithValue(ctx, contextDiagAttrs, attributes)
}</span>

type diagLogHandler struct {
        target slog.Handler
}

func (h *diagLogHandler) Enabled(ctx context.Context, lvl slog.Level) bool <span class="cov4" title="3">{
        return h.target.Enabled(ctx, lvl)
}</span>

func (h *diagLogHandler) Handle(ctx context.Context, rec slog.Record) error <span class="cov5" title="5">{
        if diagAttributes, ok := ctx.Value(contextDiagAttrs).(LogAttributes); ok </span><span class="cov1" title="1">{
                rec.AddAttrs(
                        slog.Attr{Key: "correlationId", Value: diagAttributes.CorrelationID},
                )
        }</span>

        <span class="cov5" title="5">return h.target.Handle(ctx, rec)</span>
}

func (h *diagLogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov1" title="1">{
        return h.target.WithAttrs(attrs)
}</span>

func (h *diagLogHandler) WithGroup(name string) slog.Handler <span class="cov9" title="25">{
        return h.target.WithGroup(name)
}</span>

var _ slog.Handler = &amp;diagLogHandler{}

type RootLoggerOpts struct {
        output io.Writer

        jsonLogs bool

        // Info is default (zero)
        logLevel slog.Level
}

func (opts *RootLoggerOpts) WithJSONLogs(value bool) *RootLoggerOpts <span class="cov4" title="3">{
        opts.jsonLogs = value
        return opts
}</span>

func (opts *RootLoggerOpts) WithLogLevel(logLevel slog.Level) *RootLoggerOpts <span class="cov4" title="3">{
        opts.logLevel = logLevel
        return opts
}</span>

func (opts *RootLoggerOpts) WithOutput(output io.Writer) *RootLoggerOpts <span class="cov9" title="22">{
        opts.output = output
        return opts
}</span>

func (opts *RootLoggerOpts) WithOptionalOutputFile(outputFile string) *RootLoggerOpts <span class="cov2" title="2">{
        if outputFile == "" </span><span class="cov0" title="0">{
                return opts
        }</span>
        <span class="cov2" title="2">f, err := os.OpenFile(outputFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov2" title="2">opts.output = f
        return opts</span>
}

func NewRootLoggerOpts() *RootLoggerOpts <span class="cov10" title="26">{
        return &amp;RootLoggerOpts{
                output: os.Stdout,
        }
}</span>

func SetupRootLogger(opts *RootLoggerOpts) *slog.Logger <span class="cov10" title="26">{
        logHandlerOpts := &amp;slog.HandlerOptions{Level: opts.logLevel}
        var logHandler slog.Handler
        if opts.jsonLogs </span><span class="cov1" title="1">{
                logHandler = slog.NewJSONHandler(opts.output, logHandlerOpts)
        }</span> else<span class="cov9" title="25"> {
                logHandler = slog.NewTextHandler(opts.output, logHandlerOpts)
        }</span>
        <span class="cov10" title="26">return slog.New(&amp;diagLogHandler{target: logHandler})</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">//go:build !release

package diag

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "runtime"
)

// openTestLogFile will open a log file in a project root directory.
func openTestLogFile() *os.File <span class="cov5" title="5">{
        _, filename, _, _ := runtime.Caller(0) // Will be current file
        testFilePath := filepath.Join(filename, "..", "..", "..", "test.log")
        f, err := os.OpenFile(testFilePath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("fail to open log file %q for test logging: %w", testFilePath, err)
                panic(err)</span>
        }
        <span class="cov5" title="5">return f</span>
}

var testOutput = openTestLogFile() //nolint:gochecknoglobals //it's ok for tests

func RootTestLogger() *slog.Logger <span class="cov10" title="22">{
        return SetupRootLogger(
                NewRootLoggerOpts().WithOutput(testOutput),
        )
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package networking

import (
        "bufio"
        "io"
)

type Session interface {
        ClientID() string
        ReadLine() (string, error)
        WriteLine(data string) error
}

type session struct {
        clientID string
        stream   io.ReadWriter
        reader   *bufio.Reader
}

func (s *session) ClientID() string <span class="cov1" title="1">{
        return s.clientID
}</span>

func (s *session) ReadLine() (string, error) <span class="cov7" title="4">{
        line, _, err := s.reader.ReadLine()
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov6" title="3">return string(line), nil</span>
}

func (s *session) WriteLine(data string) error <span class="cov4" title="2">{
        _, err := s.stream.Write(append([]byte(data), '\n'))
        return err
}</span>

func NewSession(clientID string, stream io.ReadWriter) Session <span class="cov10" title="6">{
        return &amp;session{
                clientID,
                stream,
                bufio.NewReader(stream),
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">//go:build !release

package networking

import "github.com/go-faker/faker/v4"

type MockSession struct {
        clientID    string
        readBuffer  chan string
        writeBuffer chan string
        nextError   error
}

func (m *MockSession) ClientID() string <span class="cov10" title="19">{
        return m.clientID
}</span>

func (m *MockSession) MockSendLine(line string) <span class="cov8" title="10">{
        go func() </span><span class="cov8" title="10">{
                m.readBuffer &lt;- line
        }</span>()
}

func (m *MockSession) MockSendLineAndWaitResult(line string) string <span class="cov7" title="9">{
        go func() </span><span class="cov7" title="9">{
                m.readBuffer &lt;- line
        }</span>()
        <span class="cov7" title="9">return &lt;-m.writeBuffer</span>
}

func (m *MockSession) MockWaitResult() string <span class="cov6" title="7">{
        return &lt;-m.writeBuffer
}</span>

func (m *MockSession) MockSetNextError(err error) <span class="cov3" title="2">{
        m.nextError = err
}</span>

func (m *MockSession) ReadLine() (string, error) <span class="cov9" title="18">{
        data := &lt;-m.readBuffer
        return data, m.nextError
}</span>

func (m *MockSession) WriteLine(data string) error <span class="cov9" title="16">{
        m.writeBuffer &lt;- data
        return m.nextError
}</span>

func NewMockSession() *MockSession <span class="cov9" title="18">{
        return &amp;MockSession{
                clientID:    faker.UUIDHyphenated(),
                readBuffer:  make(chan string),
                writeBuffer: make(chan string),
        }
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package services

import (
        "crypto/rand"
        "time"
        "word-of-wisdom-go/pkg/di"

        "go.uber.org/dig"
)

type CryptoRandReader func(b []byte) (n int, err error)

func Register(container *dig.Container) error <span class="cov10" title="2">{
        return di.ProvideAll(container,
                NewTimeProvider,
                di.ProvideValue(time.NewTicker),
                di.ProvideValue(CryptoRandReader(rand.Read)),
        )
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">//go:build !release

package services

import (
        "time"

        "github.com/go-faker/faker/v4"
)

type MockNow struct {
        value time.Time
}

var _ TimeProvider = &amp;MockNow{}

func (m *MockNow) SetValue(t time.Time) <span class="cov1" title="1">{
        m.value = t
}</span>

func (m *MockNow) Increment(duration time.Duration) <span class="cov1" title="2">{
        m.value = m.value.Add(duration)
}</span>

func (m *MockNow) Now() time.Time <span class="cov10" title="524">{
        return m.value
}</span>

func NewMockNow() *MockNow <span class="cov4" title="10">{
        return &amp;MockNow{
                value: time.UnixMilli(faker.RandomUnixTime()),
        }
}</span>

func MockNowValue(p TimeProvider) time.Time <span class="cov0" title="0">{
        mp, ok := p.(*MockNow)
        if !ok </span><span class="cov0" title="0">{
                panic("provided TimeProvider is not a MockNow")</span>
        }
        <span class="cov0" title="0">return mp.value</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package services

import "time"

type TimeProvider interface {
        Now() time.Time
}

type timeProviderFn func() time.Time

func (fn timeProviderFn) Now() time.Time <span class="cov5" title="2">{
        return fn()
}</span>

func NewTimeProvider() TimeProvider <span class="cov10" title="4">{
        return timeProviderFn(time.Now)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
