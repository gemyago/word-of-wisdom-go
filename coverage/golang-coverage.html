
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">word-of-wisdom-go/cmd/client/client.go (93.9%)</option>
				
				<option value="file1">word-of-wisdom-go/cmd/client/dialer.go (88.9%)</option>
				
				<option value="file2">word-of-wisdom-go/cmd/client/main.go (57.1%)</option>
				
				<option value="file3">word-of-wisdom-go/cmd/client/root.go (91.7%)</option>
				
				<option value="file4">word-of-wisdom-go/cmd/client/solve_challenge.go (96.4%)</option>
				
				<option value="file5">word-of-wisdom-go/cmd/client/testing.go (92.1%)</option>
				
				<option value="file6">word-of-wisdom-go/cmd/client/wow.go (91.2%)</option>
				
				<option value="file7">word-of-wisdom-go/cmd/server/main.go (57.1%)</option>
				
				<option value="file8">word-of-wisdom-go/cmd/server/root.go (91.3%)</option>
				
				<option value="file9">word-of-wisdom-go/cmd/server/tcp_server.go (71.9%)</option>
				
				<option value="file10">word-of-wisdom-go/internal/api/tcp/commands/handler.go (92.9%)</option>
				
				<option value="file11">word-of-wisdom-go/internal/api/tcp/commands/register.go (100.0%)</option>
				
				<option value="file12">word-of-wisdom-go/internal/api/tcp/server/mock_command_handler.go (68.2%)</option>
				
				<option value="file13">word-of-wisdom-go/internal/api/tcp/server/register.go (100.0%)</option>
				
				<option value="file14">word-of-wisdom-go/internal/api/tcp/server/server.go (92.3%)</option>
				
				<option value="file15">word-of-wisdom-go/internal/app/challenges.go (96.2%)</option>
				
				<option value="file16">word-of-wisdom-go/internal/app/mock_challenges.go (62.1%)</option>
				
				<option value="file17">word-of-wisdom-go/internal/app/mock_request_rate_monitor.go (67.9%)</option>
				
				<option value="file18">word-of-wisdom-go/internal/app/mock_wow_query.go (67.9%)</option>
				
				<option value="file19">word-of-wisdom-go/internal/app/monitor.go (100.0%)</option>
				
				<option value="file20">word-of-wisdom-go/internal/app/register.go (100.0%)</option>
				
				<option value="file21">word-of-wisdom-go/internal/app/wow.go (100.0%)</option>
				
				<option value="file22">word-of-wisdom-go/internal/config/load.go (94.4%)</option>
				
				<option value="file23">word-of-wisdom-go/internal/config/provide.go (100.0%)</option>
				
				<option value="file24">word-of-wisdom-go/internal/di/dig.go (94.1%)</option>
				
				<option value="file25">word-of-wisdom-go/internal/diag/attributes.go (100.0%)</option>
				
				<option value="file26">word-of-wisdom-go/internal/diag/mock_slog_handler.go (34.7%)</option>
				
				<option value="file27">word-of-wisdom-go/internal/diag/slog.go (93.1%)</option>
				
				<option value="file28">word-of-wisdom-go/internal/diag/testing.go (75.0%)</option>
				
				<option value="file29">word-of-wisdom-go/internal/services/register.go (100.0%)</option>
				
				<option value="file30">word-of-wisdom-go/internal/services/session_io.go (100.0%)</option>
				
				<option value="file31">word-of-wisdom-go/internal/services/testing.go (86.7%)</option>
				
				<option value="file32">word-of-wisdom-go/internal/services/time.go (100.0%)</option>
				
				<option value="file33">word-of-wisdom-go/internal/services/uuid.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "os"
        "time"
        "word-of-wisdom-go/internal/diag"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

type runWOWCommandParams struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        // config
        MaxSessionDuration time.Duration `name:"config.client.maxSessionDuration"`

        // client specific deps
        SessionDialer
        WOWCommand

        // Expected in a form host:port
        serverAddress string
        output        io.Writer
}

func writeLines(w io.Writer, lines ...string) error <span class="cov5" title="2">{
        for _, line := range lines </span><span class="cov10" title="4">{
                if _, err := fmt.Fprintln(w, line); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write line: %w", err)
                }</span>
        }
        <span class="cov5" title="2">return nil</span>
}

func runWOWCommand(ctx context.Context, params runWOWCommandParams) error <span class="cov10" title="4">{
        ctx, cancel := context.WithDeadline(ctx, time.Now().Add(params.MaxSessionDuration))
        defer cancel()

        logger := params.RootLogger.WithGroup("client")
        logger.DebugContext(ctx, "Establishing connection", slog.String("address", params.serverAddress))

        session, cleanup, err := params.DialSession("tcp", params.serverAddress)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov8" title="3">defer func() </span><span class="cov8" title="3">{
                if err = cleanup(); err != nil </span><span class="cov1" title="1">{
                        logger.ErrorContext(ctx, "Connection cleanup failed", diag.ErrAttr(err))
                }</span>
        }()
        <span class="cov8" title="3">result, err := params.WOWCommand.Process(ctx, session)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov5" title="2">return writeLines(params.output,
                "Your Word of Wisdom for today:",
                result,
        )</span>
}

func newClientCmd(container *dig.Container) *cobra.Command <span class="cov10" title="4">{
        serverAddress := "localhost:44221"
        cmd := &amp;cobra.Command{
                Use:   "get-wow",
                Short: "Command to connect to the server and get word of wisdom",
        }
        cmd.Flags().StringVarP(&amp;serverAddress, "address", "a", serverAddress, "Server address to connect to")
        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Do not start. Just setup deps and exit. Useful for testing if setup is all working.",
        )
        cmd.RunE = func(cmd *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                ctx := cmd.Context()
                return container.Invoke(func(params runWOWCommandParams) error </span><span class="cov1" title="1">{
                        params.serverAddress = serverAddress
                        params.output = os.Stdout
                        if noop </span><span class="cov1" title="1">{
                                params.RootLogger.InfoContext(ctx, "Establishing connection", slog.String("address", params.serverAddress))
                                return nil
                        }</span>
                        <span class="cov0" title="0">return runWOWCommand(ctx, params)</span>
                })
        }
        <span class="cov10" title="4">return cmd</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "net"
        "time"
        "word-of-wisdom-go/internal/services"

        "go.uber.org/dig"
)

type SessionDialer interface {
        // DialSession establishes new connection and returns session and close function
        DialSession(network, address string) (*services.SessionIO, func() error, error)
}

type sessionDialerFunc func(network, address string) (*services.SessionIO, func() error, error)

func (f sessionDialerFunc) DialSession(network, address string) (*services.SessionIO, func() error, error) <span class="cov10" title="6">{
        return f(network, address)
}</span>

var _ SessionDialer = sessionDialerFunc(nil)

type SessionDialerDeps struct {
        dig.In

        // config
        IOTimeout time.Duration `name:"config.client.ioTimeout"`
}

func newSessionDialer(deps SessionDialerDeps) SessionDialer <span class="cov6" title="3">{
        return sessionDialerFunc(func(network, address string) (*services.SessionIO, func() error, error) </span><span class="cov4" title="2">{
                conn, err := net.Dial(network, address)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, nil, fmt.Errorf("error connecting to server: %w", err)
                }</span>
                <span class="cov1" title="1">if err = conn.SetDeadline(time.Now().Add(deps.IOTimeout)); err != nil </span><span class="cov0" title="0">{ // coverage-ignore // hard to simulate this
                        return nil, nil, fmt.Errorf("failed to set deadline: %w", err)
                }</span>
                <span class="cov1" title="1">session := services.NewSessionIO(conn.LocalAddr().String(), conn)
                return session, conn.Close, nil</span>
        })
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="4">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newClientCmd(container),
                newSolveChallengeCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"
        "word-of-wisdom-go/internal/app"
        "word-of-wisdom-go/internal/config"
        "word-of-wisdom-go/internal/di"
        "word-of-wisdom-go/internal/diag"
        "word-of-wisdom-go/internal/services"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="4">{
        logsOutputFile := ""
        jsonLogs := false
        env := ""

        cmd := &amp;cobra.Command{
                Use:   "client",
                Short: "WoW client",
        }
        cmd.SilenceUsage = true
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().BoolVar(
                &amp;jsonLogs,
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringVarP(
                &amp;env,
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov10" title="4">{
                cfg, err := config.Load(config.NewLoadOpts().WithEnv(env))
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov8" title="3">if err = cfg.BindPFlag("defaultLogLevel", cmd.PersistentFlags().Lookup("log-level")); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="3">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov5" title="2">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(jsonLogs).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),
                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),

                                // client specific deps
                                newSessionDialer,
                                newWOWCommand,
                                di.ProvideAs[*app.Challenges, challengesService],
                        ),

                        // app layer
                        app.Register(container),

                        // service layer
                        services.Register(container),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to inject dependencies: %w", err)
                }</span>

                <span class="cov5" title="2">return nil</span>
        }
        <span class="cov10" title="4">return cmd</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "os"
        "time"

        "github.com/samber/lo"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

type runSolveChallengeCommandParams struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        Challenges challengesService

        // client params
        challengeToSolve string
        complexity       int

        // Expected in a form host:port
        output io.Writer
}

func runSolveChallengeCommand(
        ctx context.Context,
        params runSolveChallengeCommandParams,
) error <span class="cov1" title="1">{
        startedAt := time.Now()
        solution, err := params.Challenges.SolveChallenge(
                ctx,
                params.complexity,
                params.challengeToSolve,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to solve challenge: %w", err)
        }</span>
        <span class="cov1" title="1">solutionDuration := time.Since(startedAt)

        fmt.Fprintln(params.output, "Challenge solve result")
        fmt.Fprint(params.output, "Complexity: ")
        fmt.Fprintln(params.output, params.complexity)
        fmt.Fprint(params.output, "Solution: ")
        fmt.Fprintln(params.output, solution)
        fmt.Fprint(params.output, "Duration: ")
        fmt.Fprintln(params.output, solutionDuration)
        return nil</span>
}

func newSolveChallengeCmd(container *dig.Container) *cobra.Command <span class="cov10" title="4">{
        cmd := &amp;cobra.Command{
                Use:   "solve-challenge",
                Short: "Command to test solving challenges logic",
        }
        challenge := "any text can be here"
        complexity := 1
        silent := false
        cmd.Flags().StringVar(&amp;challenge, "challenge", challenge, "Challenge to solve")
        cmd.Flags().IntVarP(&amp;complexity, "complexity", "c", complexity, "Complexity of the solution (e.g leading hash zeros)")
        cmd.Flags().BoolVar(&amp;silent, "silent", silent, "Do not produce any output. Just solve")
        cmd.RunE = func(cmd *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                ctx := cmd.Context()
                return container.Invoke(func(params runSolveChallengeCommandParams) error </span><span class="cov1" title="1">{
                        params.challengeToSolve = challenge
                        params.complexity = complexity
                        params.output = lo.If(silent, io.Discard).Else(os.Stdout)
                        return runSolveChallengeCommand(ctx, params)
                }</span>)
        }
        <span class="cov10" title="4">return cmd</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">//go:build !release

package main

import (
        "net"
        "strconv"
        "sync"
)

type connectionData struct {
        message string
}

type mockTCPServer struct {
        listener    net.Listener
        isRunning   bool
        connections []connectionData
        mu          sync.Mutex
}

func newMockTCPServer() *mockTCPServer <span class="cov1" title="1">{
        return &amp;mockTCPServer{}
}</span>

// Start initializes and starts the TCP server on a random port.
func (s *mockTCPServer) Start(port int) error <span class="cov1" title="1">{
        var err error
        s.listener, err = net.Listen("tcp", ":"+strconv.Itoa(port))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">s.isRunning = true

        startupSignal := make(chan struct{})
        go func() </span><span class="cov1" title="1">{
                startupSignal &lt;- struct{}{}
                for </span><span class="cov10" title="2">{
                        var conn net.Conn
                        conn, err = s.listener.Accept()
                        if err != nil </span><span class="cov1" title="1">{
                                if !s.isRunning </span><span class="cov1" title="1">{
                                        return
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov1" title="1">go s.handleConnection(conn)</span>
                }
        }()
        <span class="cov1" title="1">&lt;-startupSignal
        return nil</span>
}

func (s *mockTCPServer) stop() <span class="cov1" title="1">{
        s.isRunning = false
        if s.listener != nil </span><span class="cov1" title="1">{
                s.listener.Close()
        }</span>
}

func (s *mockTCPServer) handleConnection(conn net.Conn) <span class="cov1" title="1">{
        defer conn.Close()
        buffer := make([]byte, 1024)
        for </span><span class="cov10" title="2">{
                n, err := conn.Read(buffer)
                if err != nil </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov1" title="1">message := string(buffer[:n])

                s.mu.Lock()
                s.connections = append(s.connections, connectionData{message: message})
                s.mu.Unlock()

                _, err = conn.Write(buffer[:n])
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

func (s *mockTCPServer) getConnections() []connectionData <span class="cov1" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        return append([]connectionData{}, s.connections...) // Return a copy
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "context"
        "fmt"
        "log/slog"
        "strconv"
        "strings"
        "time"
        "word-of-wisdom-go/internal/api/tcp/commands"
        "word-of-wisdom-go/internal/services"

        "go.uber.org/dig"
)

type WOWCommand interface {
        Process(ctx context.Context, session *services.SessionIO) (string, error)
}

type WOWCommandFunc func(ctx context.Context, session *services.SessionIO) (string, error)

func (f WOWCommandFunc) Process(ctx context.Context, session *services.SessionIO) (string, error) <span class="cov10" title="10">{
        return f(ctx, session)
}</span>

var _ WOWCommandFunc = WOWCommandFunc(nil)

type challengesService interface {
        SolveChallenge(ctx context.Context, complexity int, challenge string) (string, error)
}

type WOWCommandDeps struct {
        dig.In

        RootLogger *slog.Logger

        // app layer
        Challenges challengesService
}

func newWOWCommand(deps WOWCommandDeps) WOWCommand <span class="cov9" title="8">{
        logger := deps.RootLogger.WithGroup("client")
        return WOWCommandFunc(func(ctx context.Context, session *services.SessionIO) (string, error) </span><span class="cov8" title="7">{
                logger.DebugContext(ctx, "Sending GET_WOW request")

                if err := session.WriteLine(commands.CommandGetWow); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to write to the server: %w", err)
                }</span>

                <span class="cov8" title="7">line, err := session.ReadLine()
                if err != nil </span><span class="cov1" title="1">{
                        return "", fmt.Errorf("failed to read the response: %w", err)
                }</span>

                <span class="cov8" title="6">logger.DebugContext(ctx, "Got response", slog.String("data", line))

                if strings.Index(line, commands.WowResponsePrefix) == 0 </span><span class="cov1" title="1">{
                        logger.DebugContext(ctx, "Got WOW response. No challenge required")
                        return strings.Trim(line[4:], " "), nil
                }</span>

                <span class="cov7" title="5">if strings.Index(line, commands.ChallengeRequiredPrefix) != 0 </span><span class="cov1" title="1">{
                        return "", fmt.Errorf("got unexpected challenge requirement response %s: %w", line, err)
                }</span>

                <span class="cov6" title="4">separatorIndex := strings.Index(line, ";")

                challenge := strings.Trim(line[len(commands.ChallengeRequiredPrefix):separatorIndex], " ")
                complexity, err := strconv.Atoi(line[separatorIndex+1:])
                if err != nil </span><span class="cov1" title="1">{
                        return "", err
                }</span>

                <span class="cov5" title="3">solveStartedAt := time.Now()
                solution, err := deps.Challenges.SolveChallenge(ctx, complexity, challenge)
                if err != nil </span><span class="cov1" title="1">{
                        return "", err
                }</span>

                <span class="cov3" title="2">logger.DebugContext(
                        ctx,
                        "Challenge solved. Sending challenge result",
                        slog.Duration("solutionDuration", time.Since(solveStartedAt)),
                        slog.String("solution", solution),
                )
                if err = session.WriteLine(commands.ChallengeResultPrefix + solution); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to write to the server: %w", err)
                }</span>

                <span class="cov3" title="2">line, err = session.ReadLine()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to read the response: %w", err)
                }</span>

                <span class="cov3" title="2">logger.DebugContext(ctx, "Got response", slog.String("data", line))

                if strings.Index(line, commands.WowResponsePrefix) == 0 </span><span class="cov1" title="1">{
                        return strings.Trim(line[4:], " "), nil
                }</span>

                <span class="cov1" title="1">return "", fmt.Errorf("got unexpected WOW response %s", line)</span>
        })
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="3">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newTCPServerCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"
        "word-of-wisdom-go/internal/api/tcp/commands"
        "word-of-wisdom-go/internal/api/tcp/server"
        "word-of-wisdom-go/internal/app"
        "word-of-wisdom-go/internal/config"
        "word-of-wisdom-go/internal/di"
        "word-of-wisdom-go/internal/diag"
        "word-of-wisdom-go/internal/services"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        logsOutputFile := ""
        jsonLogs := false
        env := ""

        cmd := &amp;cobra.Command{
                Use:   "server",
                Short: "WoW server",
        }
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().BoolVar(
                &amp;jsonLogs,
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringVarP(
                &amp;env,
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov10" title="3">{
                cfg, err := config.Load(config.NewLoadOpts().WithEnv(env))
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="2">if err = cfg.BindPFlag("defaultLogLevel", cmd.PersistentFlags().Lookup("log-level")); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov6" title="2">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov1" title="1">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(jsonLogs).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),
                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),
                        ),

                        // api layer
                        commands.Register(container),
                        server.Register(container),

                        // app layer
                        app.Register(container),

                        // services
                        services.Register(container),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to inject dependencies: %w", err)
                }</span>

                <span class="cov1" title="1">return nil</span>
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "context"
        "log/slog"
        "os/signal"
        "time"
        "word-of-wisdom-go/internal/api/tcp/server"
        "word-of-wisdom-go/internal/diag"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
        "golang.org/x/sys/unix"
)

type runTCPServerParams struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        *server.Listener

        noop bool
}

func runTCPServer(params runTCPServerParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger
        rootCtx := context.Background()

        signalCtx, cancel := signal.NotifyContext(rootCtx, unix.SIGINT, unix.SIGTERM)
        defer cancel()

        startupErrors := make(chan error, 1)
        go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Exiting now")
                        startupErrors &lt;- nil
                        return
                }</span>

                <span class="cov0" title="0">if err := params.Listener.Start(signalCtx); err != nil </span><span class="cov0" title="0">{ // coverage-ignore // challenging to simulate
                        startupErrors &lt;- err
                        return
                }</span>
        }()

        <span class="cov1" title="1">var startupErr error
        select </span>{
        case startupErr = &lt;-startupErrors:<span class="cov1" title="1"> // coverage-ignore // challenging to simulate
                if startupErr != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Server error", "err", startupErr)
                }</span> else<span class="cov1" title="1"> {
                        rootLogger.InfoContext(rootCtx, "Server stopped")
                }</span>
        case &lt;-signalCtx.Done():<span class="cov0" title="0"> // coverage-ignore // challenging to simulate
                rootLogger.InfoContext(rootCtx, "Trying to shut down gracefully")
                ts := time.Now()
                if err := params.Listener.Close(); err != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "graceful shutdown failed", diag.ErrAttr(err))
                }</span>
                <span class="cov0" title="0">rootLogger.InfoContext(rootCtx, "Service stopped",
                        slog.Duration("duration", time.Since(ts)),
                )</span>
        }
        <span class="cov1" title="1">return startupErr</span>
}

func newTCPServerCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        cmd := &amp;cobra.Command{
                Use:   "tcp",
                Short: "Start tcp server",
        }
        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Do not start. Just setup deps and exit. Useful for testing if setup is all working.",
        )
        cmd.RunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return container.Invoke(func(params runTCPServerParams) error </span><span class="cov1" title="1">{
                        params.noop = noop
                        return runTCPServer(params)
                }</span>)
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package commands

import (
        "context"
        "fmt"
        "log/slog"
        "strings"
        "word-of-wisdom-go/internal/app"
        "word-of-wisdom-go/internal/diag"
        "word-of-wisdom-go/internal/services"

        "go.uber.org/dig"
)

// protocol related constants.
const (
        CommandGetWow           = "GET_WOW"
        WowResponsePrefix       = "WOW: "
        challengeRequired       = "CHALLENGE_REQUIRED"
        ChallengeRequiredPrefix = challengeRequired + ": "
        ChallengeResultPrefix   = "CHALLENGE_RESULT: "

        errBadCmdResponse            = "ERR: BAD_CMD"
        errInternalError             = "ERR: INTERNAL_ERROR"
        errUnexpectedChallengeResult = "ERR: UNEXPECTED_CHALLENGE_RESULT"
        errChallengeVerificationFail = "ERR: CHALLENGE_VERIFICATION_FAILED"
)

type wowQuery interface {
        GetNextWoW(_ context.Context) (string, error)
}

type requestRateMonitor interface {
        RecordRequest(ctx context.Context, clientID string) (app.RecordRequestResult, error)
}

type challengesService interface {
        GenerateNewChallenge(clientID string) (string, error)
        VerifySolution(complexity int, challenge, solution string) bool
}

type CommandHandlerDeps struct {
        dig.In

        RootLogger *slog.Logger

        // components
        RequestRateMonitor requestRateMonitor
        Challenges         challengesService
        Query              wowQuery
}

type CommandHandler struct {
        deps   CommandHandlerDeps
        logger *slog.Logger
}

func (h *CommandHandler) trace(ctx context.Context, msg string, args ...any) <span class="cov8" title="7">{
        h.logger.DebugContext(ctx, msg, args...)
}</span>

func (h *CommandHandler) performChallengeVerification(
        ctx context.Context,
        session *services.SessionIO,
        monitoringResult app.RecordRequestResult,
) (bool, error) <span class="cov6" title="4">{
        var challenge string
        challenge, err := h.deps.Challenges.GenerateNewChallenge(session.ClientID())
        if err != nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("failed to generate new challenge: %w", err)
        }</span>

        <span class="cov5" title="3">h.trace(ctx, "Requiring to solve challenge", slog.Int("complexity", monitoringResult.ChallengeComplexity))
        challengeData := fmt.Sprintf(
                "%s%s;%d",
                ChallengeRequiredPrefix, challenge, monitoringResult.ChallengeComplexity)
        if err = session.WriteLine(challengeData); err != nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("failed to send challenge: %w", err)
        }</span>
        <span class="cov3" title="2">var cmd string
        if cmd, err = session.ReadLine(); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to read challenge result: %w", err)
        }</span>
        <span class="cov3" title="2">if strings.Index(cmd, ChallengeResultPrefix) != 0 </span><span class="cov0" title="0">{
                h.trace(ctx, "Got unexpected challenge result", slog.String("data", cmd))
                return false, session.WriteLine(errUnexpectedChallengeResult)
        }</span>

        <span class="cov3" title="2">if !h.deps.Challenges.VerifySolution(
                monitoringResult.ChallengeComplexity,
                challenge,
                strings.Trim(cmd[len(ChallengeResultPrefix):], " "),
        ) </span><span class="cov1" title="1">{
                h.trace(ctx, "Challenge verification failed", slog.String("data", cmd))
                return false, session.WriteLine(errChallengeVerificationFail)
        }</span>
        <span class="cov1" title="1">return true, nil</span>
}

func (h *CommandHandler) Handle(ctx context.Context, session *services.SessionIO) error <span class="cov9" title="9">{
        cmd, err := session.ReadLine()
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to read command: %w", err)
        }</span>

        // If we need to extend it to support multiple commands
        // then this will need to be refactored roughly as follows:
        // - new Commands component is added that implement all various commands
        // - the HandleCommands will read the command from the connection, and forward
        //   the processing to particular command implementation
        // Keeping it simple for now since we need just a single command.
        <span class="cov9" title="8">if cmd != CommandGetWow </span><span class="cov1" title="1">{
                h.trace(ctx, "Got bad command", slog.String("cmd", cmd))
                return session.WriteLine(errBadCmdResponse)
        }</span>

        <span class="cov8" title="7">monitoringResult, err := h.deps.RequestRateMonitor.RecordRequest(ctx, session.ClientID())
        if err != nil </span><span class="cov1" title="1">{
                h.logger.ErrorContext(ctx,
                        "Failed to record request",
                        slog.String("clientID", session.ClientID()),
                        diag.ErrAttr(err),
                )
                return session.WriteLine(errInternalError)
        }</span>

        <span class="cov8" title="6">if monitoringResult.ChallengeRequired </span><span class="cov6" title="4">{
                var ok bool
                ok, err = h.performChallengeVerification(ctx, session, monitoringResult)
                if err != nil </span><span class="cov3" title="2">{
                        return err
                }</span>
                <span class="cov3" title="2">if !ok </span><span class="cov1" title="1">{
                        return nil
                }</span>
        }

        <span class="cov5" title="3">wow, err := h.deps.Query.GetNextWoW(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get next wow: %w", err)
        }</span>

        <span class="cov3" title="2">h.trace(ctx, "Responding with WOW")
        return session.WriteLine(WowResponsePrefix + wow)</span>
}

func NewHandler(deps CommandHandlerDeps) *CommandHandler <span class="cov10" title="10">{
        return &amp;CommandHandler{
                deps:   deps,
                logger: deps.RootLogger.WithGroup("tcp.server.handler"),
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package commands

import (
        "word-of-wisdom-go/internal/app"
        "word-of-wisdom-go/internal/di"

        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(container,
                di.ProvideAs[*app.Challenges, challengesService],
                di.ProvideAs[*app.RequestRateMonitor, requestRateMonitor],
                di.ProvideAs[*app.WowQuery, wowQuery],

                NewHandler,
        )
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package server

import (
        context "context"
        services "word-of-wisdom-go/internal/services"

        mock "github.com/stretchr/testify/mock"
)

// mockCommandHandler is an autogenerated mock type for the commandHandler type
type mockCommandHandler struct {
        mock.Mock
}

type mockCommandHandler_Expecter struct {
        mock *mock.Mock
}

func (_m *mockCommandHandler) EXPECT() *mockCommandHandler_Expecter <span class="cov7" title="3">{
        return &amp;mockCommandHandler_Expecter{mock: &amp;_m.Mock}
}</span>

// Handle provides a mock function with given fields: ctx, session
func (_m *mockCommandHandler) Handle(ctx context.Context, session *services.SessionIO) error <span class="cov7" title="3">{
        ret := _m.Called(ctx, session)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Handle")</span>
        }

        <span class="cov7" title="3">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *services.SessionIO) error); ok </span><span class="cov7" title="3">{
                r0 = rf(ctx, session)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov4" title="2">return r0</span>
}

// mockCommandHandler_Handle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Handle'
type mockCommandHandler_Handle_Call struct {
        *mock.Call
}

// Handle is a helper method to define mock.On call
//   - ctx context.Context
//   - session *services.SessionIO
func (_e *mockCommandHandler_Expecter) Handle(ctx interface{}, session interface{}) *mockCommandHandler_Handle_Call <span class="cov7" title="3">{
        return &amp;mockCommandHandler_Handle_Call{Call: _e.mock.On("Handle", ctx, session)}
}</span>

func (_c *mockCommandHandler_Handle_Call) Run(run func(ctx context.Context, session *services.SessionIO)) *mockCommandHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*services.SessionIO))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *mockCommandHandler_Handle_Call) Return(_a0 error) *mockCommandHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *mockCommandHandler_Handle_Call) RunAndReturn(run func(context.Context, *services.SessionIO) error) *mockCommandHandler_Handle_Call <span class="cov7" title="3">{
        _c.Call.Return(run)
        return _c
}</span>

// newMockCommandHandler creates a new instance of mockCommandHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockCommandHandler(t interface {
        mock.TestingT
        Cleanup(func())
}) *mockCommandHandler <span class="cov10" title="5">{
        mock := &amp;mockCommandHandler{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="5">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="5">return mock</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package server

import (
        "word-of-wisdom-go/internal/api/tcp/commands"
        "word-of-wisdom-go/internal/di"

        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(container,
                di.ProvideAs[*commands.CommandHandler, commandHandler],

                NewListener,
        )
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package server

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net"
        "runtime/debug"
        "strings"
        "time"
        "word-of-wisdom-go/internal/diag"
        "word-of-wisdom-go/internal/services"

        "go.uber.org/dig"
)

type commandHandler interface {
        Handle(ctx context.Context, session *services.SessionIO) error
}

type ListenerDeps struct {
        dig.In

        RootLogger *slog.Logger

        // config
        Port               int           `name:"config.tcpServer.port"`
        MaxSessionDuration time.Duration `name:"config.tcpServer.maxSessionDuration"`

        // components
        Handler commandHandler

        // services
        services.UUIDGenerator
}

type Listener struct {
        logger             *slog.Logger
        listener           net.Listener
        commandHandler     commandHandler
        port               int
        maxSessionDuration time.Duration
        listeningSignal    chan struct{}
        uuidGenerator      services.UUIDGenerator
}

func NewListener(deps ListenerDeps) *Listener <span class="cov10" title="7">{
        return &amp;Listener{
                port:               deps.Port,
                maxSessionDuration: deps.MaxSessionDuration,
                commandHandler:     deps.Handler,
                logger:             deps.RootLogger.WithGroup("tcp.server"),
                listeningSignal:    make(chan struct{}),
                uuidGenerator:      deps.UUIDGenerator,
        }
}</span>

func extractHost(addr string) string <span class="cov8" title="5">{
        sepIndex := strings.Index(addr, ":")
        if sepIndex &gt;= 0 </span><span class="cov7" title="4">{
                return addr[:sepIndex]
        }</span>
        <span class="cov1" title="1">return addr</span>
}

func (l *Listener) processAcceptedConnection(ctx context.Context, c net.Conn) <span class="cov6" title="3">{
        // This can be transformed into a middleware like approach
        ctx = diag.SetLogAttributesToContext(
                ctx, diag.LogAttributes{CorrelationID: slog.StringValue(l.uuidGenerator())},
        )
        defer func() </span><span class="cov6" title="3">{
                if rvr := recover(); rvr != nil </span><span class="cov1" title="1">{
                        l.logger.ErrorContext(
                                ctx,
                                "Unhandled panic",
                                slog.Any("panic", rvr),
                                slog.String("stack", string(debug.Stack())),
                        )
                        c.Close()
                }</span>
        }()
        <span class="cov6" title="3">deadline := time.Now().Add(l.maxSessionDuration)
        ctx, cancel := context.WithDeadline(ctx, deadline)
        defer cancel()

        remoteAddr := c.RemoteAddr().String()
        if err := c.SetDeadline(deadline); err != nil </span><span class="cov0" title="0">{
                l.logger.ErrorContext(ctx,
                        "Failed to set connection deadline",
                        diag.ErrAttr(err),
                        slog.String("remoteAddr", remoteAddr),
                )
                return
        }</span>

        <span class="cov6" title="3">l.logger.InfoContext(ctx, "Connection accepted", slog.String("remoteAddr", remoteAddr))
        defer c.Close()
        session := services.NewSessionIO(extractHost(remoteAddr), c)
        if err := l.commandHandler.Handle(ctx, session); err != nil </span><span class="cov1" title="1">{
                l.logger.ErrorContext(ctx,
                        "Failed processing command",
                        diag.ErrAttr(err),
                        slog.String("remoteAddr", remoteAddr),
                )
        }</span>
}

func (l *Listener) Start(ctx context.Context) error <span class="cov8" title="5">{
        l.logger.InfoContext(ctx, "Starting tcp listener", slog.Int("port", l.port))
        var err error
        l.listener, err = net.Listen("tcp", fmt.Sprintf(":%d", l.port))
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to start listener: %w", err)
        }</span>
        <span class="cov7" title="4">close(l.listeningSignal)

        for </span><span class="cov10" title="7">{
                c, acceptErr := l.listener.Accept()
                if acceptErr != nil </span><span class="cov7" title="4">{
                        // Server stopped
                        if errors.Is(acceptErr, net.ErrClosed) </span><span class="cov7" title="4">{
                                return nil
                        }</span>

                        // Not sure if it worth shutting down the server. Logging for now
                        // Ideally we add a health check that will prove that the server is alive
                        <span class="cov0" title="0">l.logger.ErrorContext(ctx, "failed to accept connection", diag.ErrAttr(acceptErr))</span>
                } else<span class="cov6" title="3"> {
                        go l.processAcceptedConnection(ctx, c)
                }</span>
        }
}

func (l *Listener) WaitListening() <span class="cov7" title="4">{
        &lt;-l.listeningSignal
}</span>

func (l *Listener) Close() error <span class="cov8" title="5">{
        if l.listener == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov7" title="4">return l.listener.Close()</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package app

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "math/big"
        "strconv"
        "time"
        "word-of-wisdom-go/internal/services"

        "go.uber.org/dig"
)

const zeroByte = 48

func computeHash(input []byte) []byte <span class="cov9" title="7756957">{
        hash := sha256.New()
        hash.Write(input)
        return hash.Sum(nil)
}</span>

func countLeadingZeros(hash []byte) int <span class="cov9" title="7757177">{
        count := 0
        for _, char := range hash </span><span class="cov10" title="7788688">{
                if char == zeroByte </span><span class="cov6" title="31511">{
                        count++
                }</span> else<span class="cov9" title="7757177"> {
                        break</span>
                }
        }
        <span class="cov9" title="7757177">return count</span>
}

type Deps struct {
        dig.In `ignore-unexported:"true"`

        // config
        MaxSolveChallengeDuration time.Duration `name:"config.challenges.maxSolveChallengeDuration"`

        // services
        services.TimeProvider
        services.CryptoRandReader

        computeHashFn func(input []byte) []byte
}

type Challenges struct {
        deps Deps
}

func (c *Challenges) generateRandomBytes(size int) ([]byte, error) <span class="cov1" title="2">{
        nonce := make([]byte, size)
        _, err := c.deps.CryptoRandReader(nonce)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="2">return nonce, nil</span>
}

func (c *Challenges) GenerateNewChallenge(clientID string) (string, error) <span class="cov1" title="2">{
        nowBytes := big.NewInt(c.deps.Now().UnixNano()).Bytes()
        nonce, err := c.generateRandomBytes(16) // TODO: may need to make it smaller (or configurable)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="2">challengeBytes := make([]byte, len(nowBytes)+len(nonce)+len(clientID))
        copy(challengeBytes, []byte(clientID))
        copy(challengeBytes[len(clientID):], nowBytes)
        copy(challengeBytes[len(clientID)+len(nowBytes):], nonce)
        return hex.EncodeToString(challengeBytes), nil</span>
}

func (c *Challenges) VerifySolution(
        complexity int,
        challenge string,
        solution string,
) bool <span class="cov1" title="3">{
        hashInputBytes := make([]byte, len(challenge)+len(solution)+1)
        copy(hashInputBytes, []byte(challenge))
        hashInputBytes[len(challenge)] = ':'
        copy(hashInputBytes[len(challenge)+1:], []byte(solution))
        actualHash := c.deps.computeHashFn(hashInputBytes)
        leadingZerosNum := countLeadingZeros(actualHash)
        return leadingZerosNum &gt;= complexity
}</span>

// SolveChallenge returns a nonce that is a solution of the challenge.
// It is used by client side only and
// in real world scenario this may sit in it's own repo
// but keeping it simple for now.
// Returns error if the solution was not found.
func (c *Challenges) SolveChallenge(ctx context.Context, complexity int, challenge string) (string, error) <span class="cov1" title="5">{
        challengePartEnd := len(challenge)
        hashInput := make([]byte, challengePartEnd+20) // we reserve 20 bytes for solution which should be enough
        copy(hashInput, []byte(challenge))
        hashInput[challengePartEnd] = ':'
        nonce := 0

        deadline, hasDeadline := ctx.Deadline()
        if !hasDeadline </span><span class="cov1" title="4">{
                deadline = c.deps.Now().Add(c.deps.MaxSolveChallengeDuration)
        }</span>

        /*
                This can be parallelised however some research &amp; benchmarking are required.
                Straight forward approach was attempted that didn't prove to be more performant
                than serial approach, roughly:
                - GOMAXPROCS goroutines where running the hash computation below
                - Separate goroutine is generating nonces and feeding them to the above
                        worker pool via channel
                Benchmark has proven that at least up to complexity 3 the serial approach is
                faster
        */
        <span class="cov1" title="5">for </span><span class="cov9" title="7757174">{
                nonceStr := strconv.Itoa(nonce)
                copy(hashInput[challengePartEnd+1:], []byte(nonceStr))
                hash := c.deps.computeHashFn(hashInput[:challengePartEnd+1+len(nonceStr)])
                leadingZeros := countLeadingZeros(hash)
                if leadingZeros &gt;= complexity </span><span class="cov1" title="3">{
                        return nonceStr, nil
                }</span>

                <span class="cov9" title="7757171">if c.deps.Now().UnixNano() &gt;= deadline.UnixNano() </span><span class="cov1" title="2">{
                        break</span>
                }

                <span class="cov9" title="7757169">nonce++</span>
        }
        <span class="cov1" title="2">return "", errors.New("failed to solve challenge: deadline reached")</span>
}

func NewChallenges(deps Deps) *Challenges <span class="cov2" title="10">{
        if deps.computeHashFn == nil </span><span class="cov1" title="5">{
                deps.computeHashFn = computeHash
        }</span>
        <span class="cov2" title="10">return &amp;Challenges{
                deps: deps,
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockChallenges is an autogenerated mock type for the mockChallenges type
type MockChallenges struct {
        mock.Mock
}

type MockChallenges_Expecter struct {
        mock *mock.Mock
}

func (_m *MockChallenges) EXPECT() *MockChallenges_Expecter <span class="cov8" title="9">{
        return &amp;MockChallenges_Expecter{mock: &amp;_m.Mock}
}</span>

// GenerateNewChallenge provides a mock function with given fields: clientID
func (_m *MockChallenges) GenerateNewChallenge(clientID string) (string, error) <span class="cov5" title="4">{
        ret := _m.Called(clientID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GenerateNewChallenge")</span>
        }

        <span class="cov5" title="4">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(clientID)
        }</span>
        <span class="cov5" title="4">if rf, ok := ret.Get(0).(func(string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(clientID)
        }</span> else<span class="cov5" title="4"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov5" title="4">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(clientID)
        }</span> else<span class="cov5" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="4">return r0, r1</span>
}

// MockChallenges_GenerateNewChallenge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateNewChallenge'
type MockChallenges_GenerateNewChallenge_Call struct {
        *mock.Call
}

// GenerateNewChallenge is a helper method to define mock.On call
//   - clientID string
func (_e *MockChallenges_Expecter) GenerateNewChallenge(clientID interface{}) *MockChallenges_GenerateNewChallenge_Call <span class="cov5" title="4">{
        return &amp;MockChallenges_GenerateNewChallenge_Call{Call: _e.mock.On("GenerateNewChallenge", clientID)}
}</span>

func (_c *MockChallenges_GenerateNewChallenge_Call) Run(run func(clientID string)) *MockChallenges_GenerateNewChallenge_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockChallenges_GenerateNewChallenge_Call) Return(_a0 string, _a1 error) *MockChallenges_GenerateNewChallenge_Call <span class="cov5" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockChallenges_GenerateNewChallenge_Call) RunAndReturn(run func(string) (string, error)) *MockChallenges_GenerateNewChallenge_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// SolveChallenge provides a mock function with given fields: ctx, complexity, challenge
func (_m *MockChallenges) SolveChallenge(ctx context.Context, complexity int, challenge string) (string, error) <span class="cov4" title="3">{
        ret := _m.Called(ctx, complexity, challenge)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SolveChallenge")</span>
        }

        <span class="cov4" title="3">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int, string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, complexity, challenge)
        }</span>
        <span class="cov4" title="3">if rf, ok := ret.Get(0).(func(context.Context, int, string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, complexity, challenge)
        }</span> else<span class="cov4" title="3"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov4" title="3">if rf, ok := ret.Get(1).(func(context.Context, int, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, complexity, challenge)
        }</span> else<span class="cov4" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="3">return r0, r1</span>
}

// MockChallenges_SolveChallenge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SolveChallenge'
type MockChallenges_SolveChallenge_Call struct {
        *mock.Call
}

// SolveChallenge is a helper method to define mock.On call
//   - ctx context.Context
//   - complexity int
//   - challenge string
func (_e *MockChallenges_Expecter) SolveChallenge(ctx interface{}, complexity interface{}, challenge interface{}) *MockChallenges_SolveChallenge_Call <span class="cov4" title="3">{
        return &amp;MockChallenges_SolveChallenge_Call{Call: _e.mock.On("SolveChallenge", ctx, complexity, challenge)}
}</span>

func (_c *MockChallenges_SolveChallenge_Call) Run(run func(ctx context.Context, complexity int, challenge string)) *MockChallenges_SolveChallenge_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(int), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockChallenges_SolveChallenge_Call) Return(_a0 string, _a1 error) *MockChallenges_SolveChallenge_Call <span class="cov4" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockChallenges_SolveChallenge_Call) RunAndReturn(run func(context.Context, int, string) (string, error)) *MockChallenges_SolveChallenge_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// VerifySolution provides a mock function with given fields: complexity, challenge, solution
func (_m *MockChallenges) VerifySolution(complexity int, challenge string, solution string) bool <span class="cov3" title="2">{
        ret := _m.Called(complexity, challenge, solution)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for VerifySolution")</span>
        }

        <span class="cov3" title="2">var r0 bool
        if rf, ok := ret.Get(0).(func(int, string, string) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(complexity, challenge, solution)
        }</span> else<span class="cov3" title="2"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov3" title="2">return r0</span>
}

// MockChallenges_VerifySolution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifySolution'
type MockChallenges_VerifySolution_Call struct {
        *mock.Call
}

// VerifySolution is a helper method to define mock.On call
//   - complexity int
//   - challenge string
//   - solution string
func (_e *MockChallenges_Expecter) VerifySolution(complexity interface{}, challenge interface{}, solution interface{}) *MockChallenges_VerifySolution_Call <span class="cov3" title="2">{
        return &amp;MockChallenges_VerifySolution_Call{Call: _e.mock.On("VerifySolution", complexity, challenge, solution)}
}</span>

func (_c *MockChallenges_VerifySolution_Call) Run(run func(complexity int, challenge string, solution string)) *MockChallenges_VerifySolution_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(int), args[1].(string), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockChallenges_VerifySolution_Call) Return(_a0 bool) *MockChallenges_VerifySolution_Call <span class="cov3" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockChallenges_VerifySolution_Call) RunAndReturn(run func(int, string, string) bool) *MockChallenges_VerifySolution_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockChallenges creates a new instance of MockChallenges. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockChallenges(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockChallenges <span class="cov10" title="16">{
        mock := &amp;MockChallenges{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="16">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="16">return mock</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockRequestRateMonitor is an autogenerated mock type for the mockRequestRateMonitor type
type MockRequestRateMonitor struct {
        mock.Mock
}

type MockRequestRateMonitor_Expecter struct {
        mock *mock.Mock
}

func (_m *MockRequestRateMonitor) EXPECT() *MockRequestRateMonitor_Expecter <span class="cov8" title="7">{
        return &amp;MockRequestRateMonitor_Expecter{mock: &amp;_m.Mock}
}</span>

// RecordRequest provides a mock function with given fields: ctx, clientID
func (_m *MockRequestRateMonitor) RecordRequest(ctx context.Context, clientID string) (RecordRequestResult, error) <span class="cov8" title="7">{
        ret := _m.Called(ctx, clientID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for RecordRequest")</span>
        }

        <span class="cov8" title="7">var r0 RecordRequestResult
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (RecordRequestResult, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, clientID)
        }</span>
        <span class="cov8" title="7">if rf, ok := ret.Get(0).(func(context.Context, string) RecordRequestResult); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, clientID)
        }</span> else<span class="cov8" title="7"> {
                r0 = ret.Get(0).(RecordRequestResult)
        }</span>

        <span class="cov8" title="7">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, clientID)
        }</span> else<span class="cov8" title="7"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="7">return r0, r1</span>
}

// MockRequestRateMonitor_RecordRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordRequest'
type MockRequestRateMonitor_RecordRequest_Call struct {
        *mock.Call
}

// RecordRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - clientID string
func (_e *MockRequestRateMonitor_Expecter) RecordRequest(ctx interface{}, clientID interface{}) *MockRequestRateMonitor_RecordRequest_Call <span class="cov8" title="7">{
        return &amp;MockRequestRateMonitor_RecordRequest_Call{Call: _e.mock.On("RecordRequest", ctx, clientID)}
}</span>

func (_c *MockRequestRateMonitor_RecordRequest_Call) Run(run func(ctx context.Context, clientID string)) *MockRequestRateMonitor_RecordRequest_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockRequestRateMonitor_RecordRequest_Call) Return(_a0 RecordRequestResult, _a1 error) *MockRequestRateMonitor_RecordRequest_Call <span class="cov8" title="7">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockRequestRateMonitor_RecordRequest_Call) RunAndReturn(run func(context.Context, string) (RecordRequestResult, error)) *MockRequestRateMonitor_RecordRequest_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockRequestRateMonitor creates a new instance of MockRequestRateMonitor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRequestRateMonitor(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockRequestRateMonitor <span class="cov10" title="9">{
        mock := &amp;MockRequestRateMonitor{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="9">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="9">return mock</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockWowQuery is an autogenerated mock type for the mockWowQuery type
type MockWowQuery struct {
        mock.Mock
}

type MockWowQuery_Expecter struct {
        mock *mock.Mock
}

func (_m *MockWowQuery) EXPECT() *MockWowQuery_Expecter <span class="cov5" title="3">{
        return &amp;MockWowQuery_Expecter{mock: &amp;_m.Mock}
}</span>

// GetNextWoW provides a mock function with given fields: _a0
func (_m *MockWowQuery) GetNextWoW(_a0 context.Context) (string, error) <span class="cov5" title="3">{
        ret := _m.Called(_a0)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetNextWoW")</span>
        }

        <span class="cov5" title="3">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0)
        }</span>
        <span class="cov5" title="3">if rf, ok := ret.Get(0).(func(context.Context) string); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0)
        }</span> else<span class="cov5" title="3"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov5" title="3">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0)
        }</span> else<span class="cov5" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="3">return r0, r1</span>
}

// MockWowQuery_GetNextWoW_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextWoW'
type MockWowQuery_GetNextWoW_Call struct {
        *mock.Call
}

// GetNextWoW is a helper method to define mock.On call
//   - _a0 context.Context
func (_e *MockWowQuery_Expecter) GetNextWoW(_a0 interface{}) *MockWowQuery_GetNextWoW_Call <span class="cov5" title="3">{
        return &amp;MockWowQuery_GetNextWoW_Call{Call: _e.mock.On("GetNextWoW", _a0)}
}</span>

func (_c *MockWowQuery_GetNextWoW_Call) Run(run func(_a0 context.Context)) *MockWowQuery_GetNextWoW_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWowQuery_GetNextWoW_Call) Return(_a0 string, _a1 error) *MockWowQuery_GetNextWoW_Call <span class="cov5" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockWowQuery_GetNextWoW_Call) RunAndReturn(run func(context.Context) (string, error)) *MockWowQuery_GetNextWoW_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockWowQuery creates a new instance of MockWowQuery. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWowQuery(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockWowQuery <span class="cov10" title="9">{
        mock := &amp;MockWowQuery{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="9">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="9">return mock</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package app

import (
        "context"
        "sync"
        "sync/atomic"
        "time"
        "word-of-wisdom-go/internal/services"

        "github.com/samber/lo"
        "go.uber.org/dig"
)

type RecordRequestResult struct {
        ChallengeRequired   bool
        ChallengeComplexity int
}

type ChallengeConditionFunc func(nextClientCount, nextGlobalCount int64) RecordRequestResult

type RequestRateMonitorDeps struct {
        dig.In `ignore-unexported:"true"`

        // config

        // WindowDuration specifies max window duration to reset metrics
        WindowDuration time.Duration `name:"config.monitoring.windowDuration"`

        // MaxUnverifiedClientRequests max allowed unverified requests per client within the window
        MaxUnverifiedClientRequests int64 `name:"config.monitoring.maxUnverifiedClientRequests"`

        // MaxUnverifiedRequests max allowed unverified requests globally within the window
        MaxUnverifiedRequests int64 `name:"config.monitoring.maxUnverifiedRequests"`

        // services
        services.TimeProvider

        // local deps
        challengeConditionFunc ChallengeConditionFunc
}

type RequestRateMonitor struct {
        deps RequestRateMonitorDeps

        requestRateByClient sync.Map
        globalRequestsCount atomic.Int64

        // timestamp in ms when the window was started
        windowStartedAt atomic.Int64
}

// challengeCondition defines if challenge will be required and the complexity.
func (m *RequestRateMonitor) challengeCondition(nextClientCounter, nextGlobalCount int64) RecordRequestResult <span class="cov3" title="5">{
        challengeRequired := false
        complexityRequired := 0

        if nextClientCounter &gt; m.deps.MaxUnverifiedClientRequests </span><span class="cov2" title="2">{
                challengeRequired = true

                // We just grow it linearly, at some point (somewhere after 5 or 6)
                // it's just going to become unreasonably complex to proceed
                complexityRequired = int(nextClientCounter / m.deps.MaxUnverifiedClientRequests)
        }</span>

        <span class="cov3" title="5">if !challengeRequired &amp;&amp; nextGlobalCount &gt; m.deps.MaxUnverifiedRequests </span><span class="cov2" title="2">{
                challengeRequired = true
                globalCapacityScale := nextGlobalCount / m.deps.MaxUnverifiedRequests

                // If we're under pressure globally (current rate is 2x more than global threshold)
                // then increase min complexity for all users
                // 2 is reasonably complex, so good actors will not be impacted significantly
                complexityRequired = lo.If(globalCapacityScale &gt;= 2, 2).Else(1)
        }</span>

        // TODO: We should probably always use global complexity if it's above the caller complexity

        <span class="cov3" title="5">return RecordRequestResult{
                ChallengeRequired:   challengeRequired,
                ChallengeComplexity: complexityRequired,
        }</span>
}

func (m *RequestRateMonitor) RecordRequest(_ context.Context, clientID string) (RecordRequestResult, error) <span class="cov10" title="168">{
        // We are not using the context yet, but in a real world system it may be required
        // since we will very likely store counters somewhere

        // This is a naive implementation based on a fixed window algo
        // in a real world system we will need to support distributed scenario
        // and keep this data in something like redis, or use some other replication mechanism
        // and also use some sliding window algo with per client window.

        now := m.deps.Now().UnixMilli()
        lastTimestamp := m.windowStartedAt.Load()
        if now-lastTimestamp &gt; m.deps.WindowDuration.Milliseconds() </span><span class="cov2" title="3">{
                if m.windowStartedAt.CompareAndSwap(lastTimestamp, now) </span><span class="cov2" title="3">{
                        m.globalRequestsCount.Store(0)
                        m.requestRateByClient.Clear()
                }</span>
        }

        <span class="cov10" title="168">currentClientCounter, _ := m.requestRateByClient.LoadOrStore(clientID, new(int64))
        nextClientCounter := atomic.AddInt64(currentClientCounter.(*int64), 1)
        nextGlobalCount := m.globalRequestsCount.Add(1)

        return m.deps.challengeConditionFunc(nextClientCounter, nextGlobalCount), nil</span>
}

func NewRequestRateMonitor(deps RequestRateMonitorDeps) *RequestRateMonitor <span class="cov4" title="8">{
        m := &amp;RequestRateMonitor{
                deps: deps,
        }
        if m.deps.challengeConditionFunc == nil </span><span class="cov4" title="6">{
                m.deps.challengeConditionFunc = m.challengeCondition
        }</span>
        <span class="cov4" title="8">return m</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package app

import (
        "word-of-wisdom-go/internal/di"

        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov10" title="3">{
        return di.ProvideAll(container,
                NewChallenges,
                NewRequestRateMonitor,
                NewWowQuery,
        )
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">//nolint:lll //hardcoded wow phrases
package app

import (
        "context"
        "math/rand/v2"
)

type WowQuery struct {
        phrases []string
}

func (q *WowQuery) GetNextWoW(_ context.Context) (string, error) <span class="cov10" title="2">{
        // Using hardcoded list of phrases
        // We may want to change it to go to some API to get a next phrase
        // and fallback to the below if it failed. Or store them in a DB...

        nextIndex := rand.IntN(len(q.phrases)) //nolint:gosec //math/rand is ok here
        return q.phrases[nextIndex], nil
}</span>

func NewWowQuery() *WowQuery <span class="cov10" title="2">{
        return &amp;WowQuery{
                phrases: []string{
                        "You create your own opportunities. Success doesnt just come and find youyou have to go out and get it.",
                        "Never break your promises. Keep every promise; it makes you credible.",
                        "You are never as stuck as you think you are. Success is not final, and failure isnt fatal.",
                        "Happiness is a choice. For every minute you are angry, you lose 60 seconds of your own happiness.",
                        "Habits develop into character. Character is the result of our mental attitude and the way we spend our time.",
                        "Be happy with who you are. Being happy doesnt mean everything is perfect but that you have decided to look beyond the imperfections.",
                        "Dont seek happinesscreate it. You dont need life to go your way to be happy.",
                        "If you want to be happy, stop complaining. If you want happiness, stop complaining about how your life isnt what you want and make it into what you do want.",
                        "Asking for help is a sign of strength. Dont let your fear of being judged stop you from asking for help when you need it. Sometimes asking for help is the bravest move you can make. You dont have to go it alone.",
                        "Replace every negative thought with a positive one. A positive mind is stronger than a negative thought.",
                        "Accept what is, let go of what was, have faith in what will be. Sometimes you have to let go to let new things come in.",
                        "A mind that is stretched by a new experience can never go back to what it was. Experience is what causes a person to make new mistakes instead of old ones.",
                        "If you are not willing to learn, no one can help you. If you are determined to learn no one can stop you.",
                        "Be confident enough to encourage confidence in others. Show those around you that you have confidence in them.",
                        "Allow others to figure things out for themselves. The fixer ends up becoming the enabler. Let people figure it out for themselves; give them a chance to learn.",
                        "Confidence is essential for a successful life. Dont compare yourself to others; compare yourself to the person you were yesterday and give yourself the confidence to be better tomorrow.",
                        "Admit your mistakes and dont repeat them. If you cant admit your mistakes, you are destined to repeat them.",
                        "Be kind to yourself and forgive yourself. You cant know what you havent yet learned, you cant become proficient without first being a beginner and you cant be perfect. Welcome to the human race.",
                        "Failures are lessons in progress. Failure is always forgivable if you have the courage to learn its lessons and move forward in a new way.",
                        "Make amends with those who have wronged you. Apologizing doesnt always mean that youre wrong and the other person is right. It just means that you value your relationships more than your ego.",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package config

import (
        "embed"
        "fmt"

        "github.com/spf13/viper"
)

//go:embed *.json
var resources embed.FS

func mergeResourceCfg(cfg *viper.Viper, resourceName string) error <span class="cov10" title="21">{
        resourceStream, err := resources.Open(resourceName)
        if err != nil </span><span class="cov5" title="4">{
                return fmt.Errorf("failed to read config %v: %w", resourceName, err)
        }</span>
        <span class="cov9" title="17">defer resourceStream.Close()

        if err = cfg.MergeConfig(resourceStream); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config %v: %w", resourceName, err)
        }</span>
        <span class="cov9" title="17">return nil</span>
}

type LoadOpts struct {
        env                   string
        defaultConfigFileName string
}

func (opts *LoadOpts) WithEnv(val string) *LoadOpts <span class="cov7" title="9">{
        if val != "" </span><span class="cov5" title="4">{
                opts.env = val
        }</span>
        <span class="cov7" title="9">return opts</span>
}

func NewLoadOpts() *LoadOpts <span class="cov8" title="11">{
        return &amp;LoadOpts{
                env:                   "local",
                defaultConfigFileName: "default.json",
        }
}</span>

func Load(opts *LoadOpts) (*viper.Viper, error) <span class="cov8" title="11">{
        cfg := viper.New()
        cfg.SetConfigType("json")

        if err := mergeResourceCfg(cfg, opts.defaultConfigFileName); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov7" title="10">if err := mergeResourceCfg(cfg, opts.env+".json"); err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov6" title="7">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package config

import (
        "fmt"
        "word-of-wisdom-go/internal/di"

        "github.com/spf13/viper"
        "go.uber.org/dig"
)

type configValueProvider struct {
        cfg        *viper.Viper
        configPath string
        diPath     string
}

func provideConfigValue(cfg *viper.Viper, path string) configValueProvider <span class="cov10" title="30">{
        if !cfg.IsSet(path) </span><span class="cov1" title="1">{
                panic(fmt.Errorf("config key not found: %s", path))</span>
        }
        <span class="cov9" title="29">return configValueProvider{cfg, path, "config." + path}</span>
}

func (p configValueProvider) asInt() di.ConstructorWithOpts <span class="cov4" title="4">{
        return di.ProvideValue(p.cfg.GetInt(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asInt64() di.ConstructorWithOpts <span class="cov6" title="7">{
        return di.ProvideValue(p.cfg.GetInt64(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asString() di.ConstructorWithOpts <span class="cov1" title="1">{
        return di.ProvideValue(p.cfg.GetString(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asBool() di.ConstructorWithOpts <span class="cov1" title="1">{
        return di.ProvideValue(p.cfg.GetBool(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asDuration() di.ConstructorWithOpts <span class="cov8" title="16">{
        return di.ProvideValue(p.cfg.GetDuration(p.configPath), dig.Name(p.diPath))
}</span>

func Provide(container *dig.Container, cfg *viper.Viper) error <span class="cov3" title="3">{
        return di.ProvideAll(container,
                // tcp server config
                provideConfigValue(cfg, "tcpServer.port").asInt(),
                provideConfigValue(cfg, "tcpServer.maxSessionDuration").asDuration(),

                // client config
                provideConfigValue(cfg, "client.ioTimeout").asDuration(),
                provideConfigValue(cfg, "client.maxSessionDuration").asDuration(),

                // monitoring config
                provideConfigValue(cfg, "monitoring.windowDuration").asDuration(),
                provideConfigValue(cfg, "monitoring.maxUnverifiedClientRequests").asInt64(),
                provideConfigValue(cfg, "monitoring.maxUnverifiedRequests").asInt64(),

                // challenges config
                provideConfigValue(cfg, "challenges.maxSolveChallengeDuration").asDuration(),
        )
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package di

import (
        "fmt"

        "go.uber.org/dig"
)

// Dig is used as DI toolkit https://pkg.go.dev/go.uber.org/dig
// we are not creating any abstraction over it, but we do have a set of tools to make it easier to use

type ConstructorWithOpts struct {
        Constructor interface{}
        Options     []dig.ProvideOption
}

func ProvideAll(container *dig.Container, providers ...interface{}) error <span class="cov7" title="25">{
        for i, provider := range providers </span><span class="cov10" title="76">{
                switch p := provider.(type) </span>{
                case ConstructorWithOpts:<span class="cov8" title="43">
                        if err := container.Provide(p.Constructor, p.Options...); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                default:<span class="cov8" title="33">
                        if err := container.Provide(provider); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                }
        }
        <span class="cov7" title="23">return nil</span>
}

// ProvideValue will create a constructor (e.g func) from a given value.
func ProvideValue[T any](val T, opts ...dig.ProvideOption) ConstructorWithOpts <span class="cov8" title="44">{
        return ConstructorWithOpts{
                Constructor: func() T </span><span class="cov7" title="25">{ return val }</span>,
                Options:     opts,
        }
}

// ProvideWithArg will create a constructor with a first arg explicitly provided
// supposed return no error.
func ProvideWithArg[
        TArg any,
        TConstructorArg any,
        TRes any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) TRes,
) func(TConstructorArg) TRes <span class="cov1" title="1">{
        return func(cArg TConstructorArg) TRes </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideWithArgErr will create a constructor with a first arg explicitly provided
// supposed return an error.
func ProvideWithArgErr[
        TArg any,
        TConstructorArg any,
        TDep any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) (TDep, error),
) func(TConstructorArg) (TDep, error) <span class="cov1" title="1">{
        return func(cArg TConstructorArg) (TDep, error) </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideAs is used to provide one type as another, typically
// used to provide implementation struct as particular interface.
func ProvideAs[TSource any, TTarget any](source TSource) (TTarget, error) <span class="cov4" title="6">{
        target, ok := any(source).(TTarget)
        if !ok </span><span class="cov0" title="0">{
                return target, fmt.Errorf("failed to cast %T to %T", source, target)
        }</span>
        <span class="cov4" title="6">return target, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package diag

import "log/slog"

func ErrAttr(err error) slog.Attr <span class="cov10" title="3">{
        return slog.Any("err", err)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package diag

import (
        context "context"
        slog "log/slog"

        mock "github.com/stretchr/testify/mock"
)

// MockSlogHandler is an autogenerated mock type for the Handler type
type MockSlogHandler struct {
        mock.Mock
}

type MockSlogHandler_Expecter struct {
        mock *mock.Mock
}

func (_m *MockSlogHandler) EXPECT() *MockSlogHandler_Expecter <span class="cov8" title="3">{
        return &amp;MockSlogHandler_Expecter{mock: &amp;_m.Mock}
}</span>

// Enabled provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Enabled(_a0 context.Context, _a1 slog.Level) bool <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Enabled")</span>
        }

        <span class="cov0" title="0">var r0 bool
        if rf, ok := ret.Get(0).(func(context.Context, slog.Level) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_Enabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enabled'
type MockSlogHandler_Enabled_Call struct {
        *mock.Call
}

// Enabled is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Level
func (_e *MockSlogHandler_Expecter) Enabled(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_Enabled_Call{Call: _e.mock.On("Enabled", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Enabled_Call) Run(run func(_a0 context.Context, _a1 slog.Level)) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Level))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Enabled_Call) Return(_a0 bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Enabled_Call) RunAndReturn(run func(context.Context, slog.Level) bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Handle provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Handle(_a0 context.Context, _a1 slog.Record) error <span class="cov5" title="2">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Handle")</span>
        }

        <span class="cov5" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, slog.Record) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov5" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov5" title="2">return r0</span>
}

// MockSlogHandler_Handle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Handle'
type MockSlogHandler_Handle_Call struct {
        *mock.Call
}

// Handle is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Record
func (_e *MockSlogHandler_Expecter) Handle(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        return &amp;MockSlogHandler_Handle_Call{Call: _e.mock.On("Handle", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Handle_Call) Run(run func(_a0 context.Context, _a1 slog.Record)) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Record))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Handle_Call) Return(_a0 error) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Handle_Call) RunAndReturn(run func(context.Context, slog.Record) error) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithAttrs provides a mock function with given fields: attrs
func (_m *MockSlogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov1" title="1">{
        ret := _m.Called(attrs)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithAttrs")</span>
        }

        <span class="cov1" title="1">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func([]slog.Attr) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(attrs)
        }</span> else<span class="cov1" title="1"> {
                if ret.Get(0) != nil </span><span class="cov1" title="1">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov1" title="1">return r0</span>
}

// MockSlogHandler_WithAttrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithAttrs'
type MockSlogHandler_WithAttrs_Call struct {
        *mock.Call
}

// WithAttrs is a helper method to define mock.On call
//   - attrs []slog.Attr
func (_e *MockSlogHandler_Expecter) WithAttrs(attrs interface{}) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        return &amp;MockSlogHandler_WithAttrs_Call{Call: _e.mock.On("WithAttrs", attrs)}
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) Run(run func(attrs []slog.Attr)) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].([]slog.Attr))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithAttrs_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) RunAndReturn(run func([]slog.Attr) slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithGroup provides a mock function with given fields: name
func (_m *MockSlogHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithGroup")</span>
        }

        <span class="cov0" title="0">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func(string) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_WithGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithGroup'
type MockSlogHandler_WithGroup_Call struct {
        *mock.Call
}

// WithGroup is a helper method to define mock.On call
//   - name string
func (_e *MockSlogHandler_Expecter) WithGroup(name interface{}) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_WithGroup_Call{Call: _e.mock.On("WithGroup", name)}
}</span>

func (_c *MockSlogHandler_WithGroup_Call) Run(run func(name string)) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithGroup_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithGroup_Call) RunAndReturn(run func(string) slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockSlogHandler creates a new instance of MockSlogHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSlogHandler(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockSlogHandler <span class="cov10" title="4">{
        mock := &amp;MockSlogHandler{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="4">return mock</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package diag

import (
        "context"
        "io"
        "log/slog"
        "os"
)

type contextKey string

const (
        contextDiagAttrs = contextKey("diag.context-key.log-attribs")
)

type LogAttributes struct {
        CorrelationID slog.Value
}

func GetLogAttributesFromContext(ctx context.Context) LogAttributes <span class="cov3" title="3">{
        res, _ := ctx.Value(contextDiagAttrs).(LogAttributes)
        return res
}</span>

func SetLogAttributesToContext(ctx context.Context, attributes LogAttributes) context.Context <span class="cov4" title="5">{
        return context.WithValue(ctx, contextDiagAttrs, attributes)
}</span>

type diagLogHandler struct {
        target slog.Handler
}

func (h *diagLogHandler) Enabled(ctx context.Context, lvl slog.Level) bool <span class="cov10" title="44">{
        return h.target.Enabled(ctx, lvl)
}</span>

func (h *diagLogHandler) Handle(ctx context.Context, rec slog.Record) error <span class="cov7" title="17">{
        if diagAttributes, ok := ctx.Value(contextDiagAttrs).(LogAttributes); ok </span><span class="cov5" title="6">{
                rec.AddAttrs(
                        slog.Attr{Key: "correlationId", Value: diagAttributes.CorrelationID},
                )
        }</span>

        <span class="cov7" title="17">return h.target.Handle(ctx, rec)</span>
}

func (h *diagLogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov9" title="30">{
        return &amp;diagLogHandler{target: h.target.WithAttrs(attrs)}
}</span>

func (h *diagLogHandler) WithGroup(name string) slog.Handler <span class="cov9" title="29">{
        // Using WithAttrs here since group will nest all the attributes
        // inside of it (including correlationId), which makes it harder to
        // filter logs by the correlationId.
        // Consumers can use slog.Group if some attributes needs to be grouped
        return h.WithAttrs([]slog.Attr{slog.String("group", name)})
}</span>

var _ slog.Handler = &amp;diagLogHandler{}

type RootLoggerOpts struct {
        output io.Writer

        jsonLogs bool

        // Info is default (zero)
        logLevel slog.Level
}

func (opts *RootLoggerOpts) WithJSONLogs(value bool) *RootLoggerOpts <span class="cov4" title="4">{
        opts.jsonLogs = value
        return opts
}</span>

func (opts *RootLoggerOpts) WithLogLevel(logLevel slog.Level) *RootLoggerOpts <span class="cov4" title="4">{
        opts.logLevel = logLevel
        return opts
}</span>

func (opts *RootLoggerOpts) WithOutput(output io.Writer) *RootLoggerOpts <span class="cov8" title="25">{
        opts.output = output
        return opts
}</span>

func (opts *RootLoggerOpts) WithOptionalOutputFile(outputFile string) *RootLoggerOpts <span class="cov3" title="3">{
        if outputFile == "" </span><span class="cov0" title="0">{
                return opts
        }</span>
        <span class="cov3" title="3">f, err := os.OpenFile(outputFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov3" title="3">opts.output = f
        return opts</span>
}

func NewRootLoggerOpts() *RootLoggerOpts <span class="cov9" title="30">{
        return &amp;RootLoggerOpts{
                output: os.Stdout,
        }
}</span>

func SetupRootLogger(opts *RootLoggerOpts) *slog.Logger <span class="cov9" title="30">{
        logHandlerOpts := &amp;slog.HandlerOptions{Level: opts.logLevel}
        var logHandler slog.Handler
        if opts.jsonLogs </span><span class="cov1" title="1">{
                logHandler = slog.NewJSONHandler(opts.output, logHandlerOpts)
        }</span> else<span class="cov9" title="29"> {
                logHandler = slog.NewTextHandler(opts.output, logHandlerOpts)
        }</span>
        <span class="cov9" title="30">return slog.New(&amp;diagLogHandler{target: logHandler})</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">//go:build !release

package diag

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "runtime"
)

// openTestLogFile will open a log file in a project root directory.
func openTestLogFile() *os.File <span class="cov5" title="5">{
        _, filename, _, _ := runtime.Caller(0) // Will be current file
        testFilePath := filepath.Join(filename, "..", "..", "..", "test.log")
        f, err := os.OpenFile(testFilePath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("fail to open log file %q for test logging: %w", testFilePath, err)
                panic(err)</span>
        }
        <span class="cov5" title="5">return f</span>
}

var testOutput = openTestLogFile() //nolint:gochecknoglobals //it's ok for tests

func RootTestLogger() *slog.Logger <span class="cov10" title="25">{
        return SetupRootLogger(
                NewRootLoggerOpts().WithOutput(testOutput),
        )
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "crypto/rand"
        "time"
        "word-of-wisdom-go/internal/di"

        "go.uber.org/dig"
)

type CryptoRandReader func(b []byte) (n int, err error)

func Register(container *dig.Container) error <span class="cov10" title="3">{
        return di.ProvideAll(container,
                NewTimeProvider,
                NewUUIDGenerator,
                di.ProvideValue(time.NewTicker),
                di.ProvideValue(CryptoRandReader(rand.Read)),
        )
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "bufio"
        "io"
)

type SessionIO struct {
        clientID string
        stream   io.ReadWriter
        reader   *bufio.Reader
}

func (s *SessionIO) ClientID() string <span class="cov9" title="24">{
        return s.clientID
}</span>

func (s *SessionIO) ReadLine() (string, error) <span class="cov9" title="24">{
        line, _, err := s.reader.ReadLine()
        if err != nil </span><span class="cov4" title="3">{
                return "", err
        }</span>
        <span class="cov9" title="21">return string(line), nil</span>
}

func (s *SessionIO) WriteLine(data string) error <span class="cov9" title="19">{
        _, err := s.stream.Write(append([]byte(data), '\n'))
        return err
}</span>

func NewSessionIO(clientID string, stream io.ReadWriter) *SessionIO <span class="cov10" title="26">{
        return &amp;SessionIO{
                clientID: clientID,
                stream:   stream,
                reader:   bufio.NewReader(stream),
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">//go:build !release

package services

import (
        "strings"
        "time"

        "github.com/go-faker/faker/v4"
)

type MockNow struct {
        value time.Time
}

var _ TimeProvider = &amp;MockNow{}

func (m *MockNow) SetValue(t time.Time) <span class="cov2" title="2">{
        m.value = t
}</span>

func (m *MockNow) Increment(duration time.Duration) <span class="cov1" title="1">{
        m.value = m.value.Add(duration)
}</span>

func (m *MockNow) Now() time.Time <span class="cov10" title="391">{
        return m.value
}</span>

func NewMockNow() *MockNow <span class="cov4" title="13">{
        return &amp;MockNow{
                value: time.UnixMilli(faker.RandomUnixTime()),
        }
}</span>

func MockNowValue(p TimeProvider) time.Time <span class="cov0" title="0">{
        mp, ok := p.(*MockNow)
        if !ok </span><span class="cov0" title="0">{
                panic("provided TimeProvider is not a MockNow")</span>
        }
        <span class="cov0" title="0">return mp.value</span>
}

type mockSessionIOStream struct {
        readBuffer     chan string
        writeBuffer    chan string
        nextReadError  error
        nextWriteError error
}

func (m *mockSessionIOStream) Read(p []byte) (int, error) <span class="cov5" title="20">{
        line := &lt;-m.readBuffer
        if m.nextReadError != nil </span><span class="cov2" title="2">{
                return 0, m.nextReadError
        }</span>
        <span class="cov5" title="18">copy(p, line)
        return len(line), nil</span>
}

func (m *mockSessionIOStream) Write(p []byte) (int, error) <span class="cov5" title="17">{
        line := string(p)
        go func() </span><span class="cov5" title="17">{
                m.writeBuffer &lt;- line
        }</span>()
        <span class="cov5" title="17">if m.nextWriteError != nil </span><span class="cov1" title="1">{
                return 0, m.nextWriteError
        }</span>
        <span class="cov5" title="16">return len(p), nil</span>
}

type MockSessionIOController struct {
        Session *SessionIO
        stream  *mockSessionIOStream
}

func (m *MockSessionIOController) MockSendLine(line string) <span class="cov4" title="10">{
        go func() </span><span class="cov4" title="10">{
                m.stream.readBuffer &lt;- line + "\n"
        }</span>()
}

func (m *MockSessionIOController) MockSendLineAndWaitResult(line string) string <span class="cov4" title="10">{
        go func() </span><span class="cov4" title="10">{
                m.stream.readBuffer &lt;- line + "\n"
        }</span>()
        <span class="cov4" title="10">return m.MockWaitResult()</span>
}

func (m *MockSessionIOController) MockWaitResult() string <span class="cov5" title="17">{
        result := &lt;-m.stream.writeBuffer
        return strings.TrimSuffix(result, "\n")
}</span>

func (m *MockSessionIOController) MockSetNextReadError(err error) <span class="cov2" title="2">{
        m.stream.nextReadError = err
}</span>

func (m *MockSessionIOController) MockSetNextWriteError(err error) <span class="cov1" title="1">{
        m.stream.nextWriteError = err
}</span>

func NewMockSessionIOController() *MockSessionIOController <span class="cov5" title="19">{
        stream := &amp;mockSessionIOStream{
                readBuffer:  make(chan string),
                writeBuffer: make(chan string),
        }
        return &amp;MockSessionIOController{
                Session: NewSessionIO(faker.UUIDHyphenated(), stream),
                stream:  stream,
        }
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package services

import "time"

type TimeProvider interface {
        Now() time.Time
}

type timeProviderFn func() time.Time

func (fn timeProviderFn) Now() time.Time <span class="cov10" title="7756958">{
        return fn()
}</span>

func NewTimeProvider() TimeProvider <span class="cov1" title="5">{
        return timeProviderFn(time.Now)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package services

import "github.com/gofrs/uuid/v5"

type UUIDGenerator func() string

func NewUUIDGenerator() UUIDGenerator <span class="cov10" title="6">{
        return func() string </span><span class="cov6" title="3">{
                return uuid.Must(uuid.NewV4()).String()
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
